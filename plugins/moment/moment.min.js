'use strict';
!function(global, factory) {
  if ("object" == typeof exports && "undefined" != typeof module) {
    module.exports = factory();
  } else {
    if ("function" == typeof define && define.amd) {
      define(factory);
    } else {
      global.moment = factory();
    }
  }
}(this, function() {
  /**
   * @return {?}
   */
  function hooks() {
    return oldSetupComputes.apply(null, arguments);
  }
  /**
   * @param {!Object} value
   * @return {?}
   */
  function isArray(value) {
    return value instanceof Array || "[object Array]" === Object.prototype.toString.call(value);
  }
  /**
   * @param {!Object} value
   * @return {?}
   */
  function isObject(value) {
    return null != value && "[object Object]" === Object.prototype.toString.call(value);
  }
  /**
   * @param {!Object} a
   * @param {string} b
   * @return {?}
   */
  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }
  /**
   * @param {!Object} obj
   * @return {?}
   */
  function isEmpty(obj) {
    if (Object.getOwnPropertyNames) {
      return 0 === Object.getOwnPropertyNames(obj).length;
    }
    var i;
    for (i in obj) {
      if (hasOwnProp(obj, i)) {
        return;
      }
    }
    return 1;
  }
  /**
   * @param {!Array} val
   * @return {?}
   */
  function isUndefined(val) {
    return void 0 === val;
  }
  /**
   * @param {string} value
   * @return {?}
   */
  function isNumber(value) {
    return "number" == typeof value || "[object Number]" === Object.prototype.toString.call(value);
  }
  /**
   * @param {!Object} str
   * @return {?}
   */
  function isDate(str) {
    return str instanceof Date || "[object Date]" === Object.prototype.toString.call(str);
  }
  /**
   * @param {!Array} options
   * @param {!Function} merge
   * @return {?}
   */
  function merge(options, merge) {
    /** @type {!Array} */
    var result = [];
    /** @type {number} */
    var i = 0;
    for (; i < options.length; ++i) {
      result.push(merge(options[i], i));
    }
    return result;
  }
  /**
   * @param {string} a
   * @param {string} b
   * @return {?}
   */
  function extend(a, b) {
    var prop;
    for (prop in b) {
      if (hasOwnProp(b, prop)) {
        a[prop] = b[prop];
      }
    }
    return hasOwnProp(b, "toString") && (a.toString = b.toString), hasOwnProp(b, "valueOf") && (a.valueOf = b.valueOf), a;
  }
  /**
   * @param {!Object} input
   * @param {!Object} format
   * @param {!Object} locale
   * @param {!Object} strict
   * @return {?}
   */
  function createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
  }
  /**
   * @param {!Object} config
   * @return {?}
   */
  function getParsingFlags(config) {
    return null == config._pf && (config._pf = {
      empty : false,
      unusedTokens : [],
      unusedInput : [],
      overflow : -2,
      charsLeftOver : 0,
      nullInput : false,
      invalidEra : null,
      invalidMonth : null,
      invalidFormat : false,
      userInvalidated : false,
      iso : false,
      parsedDateParts : [],
      era : null,
      meridiem : null,
      rfc2822 : false,
      weekdayMismatch : false
    }), config._pf;
  }
  /**
   * @param {!Object} m
   * @return {?}
   */
  function isValid(m) {
    if (null == m._isValid) {
      var flags = getParsingFlags(m);
      var parsedParts = some$1.call(flags.parsedDateParts, function(canCreateDiscussions) {
        return null != canCreateDiscussions;
      });
      var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
      if (m._strict && (isNowValid = isNowValid && 0 === flags.charsLeftOver && 0 === flags.unusedTokens.length && void 0 === flags.bigHour), null != Object.isFrozen && Object.isFrozen(m)) {
        return isNowValid;
      }
      m._isValid = isNowValid;
    }
    return m._isValid;
  }
  /**
   * @param {string} params
   * @return {?}
   */
  function createInvalid(params) {
    var m = createUTC(NaN);
    return null != params ? extend(getParsingFlags(m), params) : getParsingFlags(m).userInvalidated = true, m;
  }
  /**
   * @param {!Object} to
   * @param {!Object} from
   * @return {?}
   */
  function copyConfig(to, from) {
    var layer_i;
    var prop;
    var val;
    if (isUndefined(from._isAMomentObject) || (to._isAMomentObject = from._isAMomentObject), isUndefined(from._i) || (to._i = from._i), isUndefined(from._f) || (to._f = from._f), isUndefined(from._l) || (to._l = from._l), isUndefined(from._strict) || (to._strict = from._strict), isUndefined(from._tzm) || (to._tzm = from._tzm), isUndefined(from._isUTC) || (to._isUTC = from._isUTC), isUndefined(from._offset) || (to._offset = from._offset), isUndefined(from._pf) || (to._pf = getParsingFlags(from)), 
    isUndefined(from._locale) || (to._locale = from._locale), 0 < crossfilterable_layers.length) {
      /** @type {number} */
      layer_i = 0;
      for (; layer_i < crossfilterable_layers.length; layer_i++) {
        if (!isUndefined(val = from[prop = crossfilterable_layers[layer_i]])) {
          to[prop] = val;
        }
      }
    }
    return to;
  }
  /**
   * @param {!Object} config
   * @return {undefined}
   */
  function Moment(config) {
    copyConfig(this, config);
    /** @type {!Date} */
    this._d = new Date(null != config._d ? config._d.getTime() : NaN);
    if (!this.isValid()) {
      /** @type {!Date} */
      this._d = new Date(NaN);
    }
    if (false === t) {
      /** @type {boolean} */
      t = true;
      hooks.updateOffset(this);
      /** @type {boolean} */
      t = false;
    }
  }
  /**
   * @param {!Object} obj
   * @return {?}
   */
  function isMoment(obj) {
    return obj instanceof Moment || null != obj && null != obj._isAMomentObject;
  }
  /**
   * @param {string} msg
   * @return {undefined}
   */
  function printMsg(msg) {
    if (false === hooks.suppressDeprecationWarnings && "undefined" != typeof console && console.warn) {
      console.warn("Deprecation warning: " + msg);
    }
  }
  /**
   * @param {string} msg
   * @param {!Function} fn
   * @return {?}
   */
  function deprecate(msg, fn) {
    /** @type {boolean} */
    var a = true;
    return extend(function() {
      if (null != hooks.deprecationHandler && hooks.deprecationHandler(null, msg), a) {
        var url;
        var prop;
        /** @type {!Array} */
        var n = [];
        /** @type {number} */
        var i = 0;
        for (; i < arguments.length; i++) {
          if (url = "", "object" == typeof arguments[i]) {
            for (prop in url = url + ("\n[" + i + "] "), arguments[0]) {
              if (hasOwnProp(arguments[0], prop)) {
                /** @type {string} */
                url = url + (prop + ": " + arguments[0][prop] + ", ");
              }
            }
            /** @type {string} */
            url = url.slice(0, -2);
          } else {
            url = arguments[i];
          }
          n.push(url);
        }
        printMsg(msg + "\nArguments: " + Array.prototype.slice.call(n).join("") + "\n" + (new Error).stack);
        /** @type {boolean} */
        a = false;
      }
      return fn.apply(this, arguments);
    }, fn);
  }
  /**
   * @param {string} name
   * @param {string} msg
   * @return {undefined}
   */
  function deprecateSimple(name, msg) {
    if (null != hooks.deprecationHandler) {
      hooks.deprecationHandler(name, msg);
    }
    if (!processedOptions[name]) {
      printMsg(msg);
      /** @type {boolean} */
      processedOptions[name] = true;
    }
  }
  /**
   * @param {string} obj
   * @return {?}
   */
  function isFunction(obj) {
    return "undefined" != typeof Function && obj instanceof Function || "[object Function]" === Object.prototype.toString.call(obj);
  }
  /**
   * @param {string} parentConfig
   * @param {!Object} childConfig
   * @return {?}
   */
  function mergeConfigs(parentConfig, childConfig) {
    var prop;
    var res = extend({}, parentConfig);
    for (prop in childConfig) {
      if (hasOwnProp(childConfig, prop)) {
        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
          res[prop] = {};
          extend(res[prop], parentConfig[prop]);
          extend(res[prop], childConfig[prop]);
        } else {
          if (null != childConfig[prop]) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
    }
    for (prop in parentConfig) {
      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
        res[prop] = extend({}, res[prop]);
      }
    }
    return res;
  }
  /**
   * @param {string} config
   * @return {undefined}
   */
  function Locale(config) {
    if (null != config) {
      this.set(config);
    }
  }
  /**
   * @param {number} number
   * @param {number} targetLength
   * @param {string} forceSign
   * @return {?}
   */
  function zeroFill(number, targetLength, forceSign) {
    /** @type {string} */
    var absNumber = "" + Math.abs(number);
    /** @type {number} */
    var zerosToFill = targetLength - absNumber.length;
    return (0 <= number ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
  }
  /**
   * @param {!Object} token
   * @param {?} padded
   * @param {?} ordinal
   * @param {(!Function|string)} callback
   * @return {undefined}
   */
  function addFormatToken(token, padded, ordinal, callback) {
    var cb = "string" == typeof callback ? function() {
      return this[callback]();
    } : callback;
    if (token) {
      formatTokenFunctions[token] = cb;
    }
    if (padded) {
      /**
       * @return {?}
       */
      formatTokenFunctions[padded[0]] = function() {
        return zeroFill(cb.apply(this, arguments), padded[1], padded[2]);
      };
    }
    if (ordinal) {
      /**
       * @return {?}
       */
      formatTokenFunctions[ordinal] = function() {
        return this.localeData().ordinal(cb.apply(this, arguments), token);
      };
    }
  }
  /**
   * @param {!Object} m
   * @param {string} format
   * @return {?}
   */
  function format(m, format) {
    return m.isValid() ? (format = expandFormat(format, m.localeData()), formatFunctions[format] = formatFunctions[format] || function(format) {
      var key;
      var array = format.match(separator);
      /** @type {number} */
      var i = 0;
      var length = array.length;
      for (; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = (key = array[i]).match(/\[[\s\S]/) ? key.replace(/^\[|\]$/g, "") : key.replace(/\\/g, "");
        }
      }
      return function(obj) {
        /** @type {string} */
        var pix_color = "";
        /** @type {number} */
        var i = 0;
        for (; i < length; i++) {
          pix_color = pix_color + (isFunction(array[i]) ? array[i].call(obj, format) : array[i]);
        }
        return pix_color;
      };
    }(format), formatFunctions[format](m)) : m.localeData().invalidDate();
  }
  /**
   * @param {string} format
   * @param {?} locale
   * @return {?}
   */
  function expandFormat(format, locale) {
    /**
     * @param {string} input
     * @return {?}
     */
    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }
    /** @type {number} */
    var n = 5;
    /** @type {number} */
    localFormattingTokens.lastIndex = 0;
    for (; 0 <= n && localFormattingTokens.test(format);) {
      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
      /** @type {number} */
      localFormattingTokens.lastIndex = 0;
      --n;
    }
    return format;
  }
  /**
   * @param {string} unit
   * @param {string} shorthand
   * @return {undefined}
   */
  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
  }
  /**
   * @param {string} units
   * @return {?}
   */
  function normalizeUnits(units) {
    return "string" == typeof units ? aliases[units] || aliases[units.toLowerCase()] : void 0;
  }
  /**
   * @param {!Object} inputObject
   * @return {?}
   */
  function normalizeObjectUnits(inputObject) {
    var normalizedProp;
    var prop;
    var normalizedInput = {};
    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop) && (normalizedProp = normalizeUnits(prop))) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
    return normalizedInput;
  }
  /**
   * @param {string} unit
   * @param {number} priority
   * @return {undefined}
   */
  function addUnitPriority(unit, priority) {
    /** @type {number} */
    priorities[unit] = priority;
  }
  /**
   * @param {number} date
   * @return {?}
   */
  function isLeapYear(date) {
    return date % 4 == 0 && date % 100 != 0 || date % 400 == 0;
  }
  /**
   * @param {number} number
   * @return {?}
   */
  function absFloor(number) {
    return number < 0 ? Math.ceil(number) || 0 : Math.floor(number);
  }
  /**
   * @param {!Object} str
   * @return {?}
   */
  function toInt(str) {
    /** @type {number} */
    var output = +str;
    /** @type {number} */
    var svgFile = 0;
    return 0 != output && isFinite(output) && (svgFile = absFloor(output)), svgFile;
  }
  /**
   * @param {string} unit
   * @param {boolean} keepTime
   * @return {?}
   */
  function makeGetSet(unit, keepTime) {
    return function(options) {
      return null != options ? (set(this, unit, options), hooks.updateOffset(this, keepTime), this) : get(this, unit);
    };
  }
  /**
   * @param {!Object} mom
   * @param {string} unit
   * @return {?}
   */
  function get(mom, unit) {
    return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
  }
  /**
   * @param {!Object} mom
   * @param {string} unit
   * @param {number} date
   * @return {undefined}
   */
  function set(mom, unit, date) {
    if (mom.isValid() && !isNaN(date)) {
      if ("FullYear" === unit && isLeapYear(mom.year()) && 1 === mom.month() && 29 === mom.date()) {
        date = toInt(date);
        mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](date, mom.month(), daysInMonth(date, mom.month()));
      } else {
        mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](date);
      }
    }
  }
  /**
   * @param {string} token
   * @param {string} regex
   * @param {!Object} strictRegex
   * @return {undefined}
   */
  function addRegexToken(token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function(isStrict, canCreateDiscussions) {
      return isStrict && strictRegex ? strictRegex : regex;
    };
  }
  /**
   * @param {string} token
   * @param {!Object} config
   * @return {?}
   */
  function getParseRegexForToken(token, config) {
    return hasOwnProp(regexes, token) ? regexes[token](config._strict, config._locale) : new RegExp(regexEscape(token.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(canCreateDiscussions, d, n, i, cur) {
      return d || n || i || cur;
    })));
  }
  /**
   * @param {string} text
   * @return {?}
   */
  function regexEscape(text) {
    return text.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  /**
   * @param {!Object} token
   * @param {!Function} callback
   * @return {undefined}
   */
  function addParseToken(token, callback) {
    var j;
    /** @type {!Function} */
    var func = callback;
    if ("string" == typeof token) {
      /** @type {!Array} */
      token = [token];
    }
    if (isNumber(callback)) {
      /**
       * @param {!Object} input
       * @param {!Object} array
       * @return {undefined}
       */
      func = function(input, array) {
        array[callback] = toInt(input);
      };
    }
    /** @type {number} */
    j = 0;
    for (; j < token.length; j++) {
      tokens[token[j]] = func;
    }
  }
  /**
   * @param {!Array} token
   * @param {!Function} callback
   * @return {undefined}
   */
  function addWeekParseToken(token, callback) {
    addParseToken(token, function(identifierPositions, canCreateDiscussions, b, missingCoins) {
      b._w = b._w || {};
      callback(identifierPositions, b._w, b, missingCoins);
    });
  }
  /**
   * @param {number} month
   * @param {number} year
   * @return {?}
   */
  function daysInMonth(month, year) {
    if (isNaN(month) || isNaN(year)) {
      return NaN;
    }
    var F;
    /** @type {number} */
    var value_l = (year % (F = 12) + F) % F;
    return month = month + (year - value_l) / 12, 1 == value_l ? isLeapYear(month) ? 29 : 28 : 31 - value_l % 7 % 2;
  }
  /**
   * @param {!Object} mom
   * @param {number} value
   * @return {?}
   */
  function setMonth(mom, value) {
    var n;
    if (!mom.isValid()) {
      return mom;
    }
    if ("string" == typeof value) {
      if (/^\d+$/.test(value)) {
        value = toInt(value);
      } else {
        if (!isNumber(value = mom.localeData().monthsParse(value))) {
          return mom;
        }
      }
    }
    return n = Math.min(mom.date(), daysInMonth(mom.year(), value)), mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, n), mom;
  }
  /**
   * @param {number} value
   * @return {?}
   */
  function getSetMonth(value) {
    return null != value ? (setMonth(this, value), hooks.updateOffset(this, true), this) : get(this, "Month");
  }
  /**
   * @return {undefined}
   */
  function computeMonthsParse() {
    /**
     * @param {!NodeList} b
     * @param {!NodeList} a
     * @return {?}
     */
    function cmpLenRev(b, a) {
      return a.length - b.length;
    }
    var mom;
    /** @type {!Array} */
    var shortPieces = [];
    /** @type {!Array} */
    var longPieces = [];
    /** @type {!Array} */
    var mixedPieces = [];
    /** @type {number} */
    var i = 0;
    for (; i < 12; i++) {
      mom = createUTC([2E3, i]);
      shortPieces.push(this.monthsShort(mom, ""));
      longPieces.push(this.months(mom, ""));
      mixedPieces.push(this.months(mom, ""));
      mixedPieces.push(this.monthsShort(mom, ""));
    }
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    /** @type {number} */
    i = 0;
    for (; i < 12; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
    }
    /** @type {number} */
    i = 0;
    for (; i < 24; i++) {
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }
    /** @type {!RegExp} */
    this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
    /** @type {!RegExp} */
    this._monthsShortRegex = this._monthsRegex;
    /** @type {!RegExp} */
    this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
    /** @type {!RegExp} */
    this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
  }
  /**
   * @param {number} year
   * @return {?}
   */
  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }
  /**
   * @param {number} y
   * @return {?}
   */
  function createUTCDate(y) {
    var date;
    var args;
    return y < 100 && 0 <= y ? ((args = Array.prototype.slice.call(arguments))[0] = y + 400, date = new Date(Date.UTC.apply(null, args)), isFinite(date.getUTCFullYear()) && date.setUTCFullYear(y)) : date = new Date(Date.UTC.apply(null, arguments)), date;
  }
  /**
   * @param {number} year
   * @param {number} dow
   * @param {number} doy
   * @return {?}
   */
  function firstWeekOffset(year, dow, doy) {
    /** @type {number} */
    var fwd = 7 + dow - doy;
    return fwd - (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7 - 1;
  }
  /**
   * @param {number} year
   * @param {number} week
   * @param {number} weekday
   * @param {number} dow
   * @param {number} doy
   * @return {?}
   */
  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var resYear;
    var dayOfYear = 1 + 7 * (week - 1) + (7 + weekday - dow) % 7 + firstWeekOffset(year, dow, doy);
    var resDayOfYear = dayOfYear <= 0 ? daysInYear(resYear = year - 1) + dayOfYear : dayOfYear > daysInYear(year) ? (resYear = year + 1, dayOfYear - daysInYear(year)) : (resYear = year, dayOfYear);
    return {
      year : resYear,
      dayOfYear : resDayOfYear
    };
  }
  /**
   * @param {!Object} mom
   * @param {number} dow
   * @param {number} doy
   * @return {?}
   */
  function weekOfYear(mom, dow, doy) {
    var resWeek;
    var academicYear;
    var weekOffset = firstWeekOffset(mom.year(), dow, doy);
    /** @type {number} */
    var week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1;
    return week < 1 ? resWeek = week + weeksInYear(academicYear = mom.year() - 1, dow, doy) : week > weeksInYear(mom.year(), dow, doy) ? (resWeek = week - weeksInYear(mom.year(), dow, doy), academicYear = mom.year() + 1) : (academicYear = mom.year(), resWeek = week), {
      week : resWeek,
      year : academicYear
    };
  }
  /**
   * @param {number} year
   * @param {number} dow
   * @param {number} doy
   * @return {?}
   */
  function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy);
    var weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  }
  /**
   * @param {string} t
   * @param {?} e
   * @return {?}
   */
  function data_extract(t, e) {
    return t.slice(e, 7).concat(t.slice(0, e));
  }
  /**
   * @return {undefined}
   */
  function computeWeekdaysParse() {
    /**
     * @param {!NodeList} b
     * @param {!NodeList} a
     * @return {?}
     */
    function cmpLenRev(b, a) {
      return a.length - b.length;
    }
    var mom;
    var shortp;
    var longp;
    var minp;
    /** @type {!Array} */
    var shortPieces = [];
    /** @type {!Array} */
    var longPieces = [];
    /** @type {!Array} */
    var minPieces = [];
    /** @type {!Array} */
    var mixedPieces = [];
    /** @type {number} */
    var i = 0;
    for (; i < 7; i++) {
      mom = createUTC([2E3, 1]).day(i);
      shortp = regexEscape(this.weekdaysMin(mom, ""));
      longp = regexEscape(this.weekdaysShort(mom, ""));
      minp = regexEscape(this.weekdays(mom, ""));
      shortPieces.push(shortp);
      longPieces.push(longp);
      minPieces.push(minp);
      mixedPieces.push(shortp);
      mixedPieces.push(longp);
      mixedPieces.push(minp);
    }
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    minPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    /** @type {!RegExp} */
    this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
    /** @type {!RegExp} */
    this._weekdaysShortRegex = this._weekdaysRegex;
    /** @type {!RegExp} */
    this._weekdaysMinRegex = this._weekdaysRegex;
    /** @type {!RegExp} */
    this._weekdaysStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
    /** @type {!RegExp} */
    this._weekdaysShortStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
    /** @type {!RegExp} */
    this._weekdaysMinStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
  }
  /**
   * @return {?}
   */
  function hFormat() {
    return this.hours() % 12 || 12;
  }
  /**
   * @param {string} token
   * @param {string} lowercase
   * @return {undefined}
   */
  function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function() {
      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
  }
  /**
   * @param {?} isStrict
   * @param {?} locale
   * @return {?}
   */
  function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
  }
  /**
   * @param {string} key
   * @return {?}
   */
  function fn(key) {
    return key ? key.toLowerCase().replace("_", "-") : key;
  }
  /**
   * @param {number} result
   * @return {?}
   */
  function resolve(result) {
    var j;
    var next;
    var path;
    var split;
    /** @type {number} */
    var i = 0;
    for (; i < result.length;) {
      j = (split = fn(result[i]).split("-")).length;
      next = (next = fn(result[i + 1])) ? next.split("-") : null;
      for (; 0 < j;) {
        if (path = require(split.slice(0, j).join("-"))) {
          return path;
        }
        if (next && next.length >= j && function(array, expected) {
          /** @type {number} */
          var parts = Math.min(array.length, expected.length);
          /** @type {number} */
          var i = 0;
          for (; i < parts; i = i + 1) {
            if (array[i] !== expected[i]) {
              return i;
            }
          }
          return parts;
        }(split, next) >= j - 1) {
          break;
        }
        j--;
      }
      i++;
    }
    return globalLocale;
  }
  /**
   * @param {?} name
   * @return {?}
   */
  function require(name) {
    var oldLocale;
    if (void 0 === locales[name] && "undefined" != typeof module && module && module.exports) {
      try {
        oldLocale = globalLocale._abbr;
        require("./locale/" + name);
        getSetGlobalLocale(oldLocale);
      } catch (e) {
        /** @type {null} */
        locales[name] = null;
      }
    }
    return locales[name];
  }
  /**
   * @param {string} key
   * @param {!Arguments} values
   * @return {?}
   */
  function getSetGlobalLocale(key, values) {
    var data;
    return key && ((data = isUndefined(values) ? getLocale(key) : defineLocale(key, values)) ? globalLocale = data : "undefined" != typeof console && console.warn && console.warn("Locale " + key + " not found. Did you forget to load it?")), globalLocale._abbr;
  }
  /**
   * @param {string} name
   * @param {!Object} config
   * @return {?}
   */
  function defineLocale(name, config) {
    if (null === config) {
      return delete locales[name], null;
    }
    var transport;
    var parentConfig = baseConfig;
    if (config.abbr = name, null != locales[name]) {
      deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
      parentConfig = locales[name]._config;
    } else {
      if (null != config.parentLocale) {
        if (null != locales[config.parentLocale]) {
          parentConfig = locales[config.parentLocale]._config;
        } else {
          if (null == (transport = require(config.parentLocale))) {
            return localeFamilies[config.parentLocale] || (localeFamilies[config.parentLocale] = []), localeFamilies[config.parentLocale].push({
              name : name,
              config : config
            }), null;
          }
          parentConfig = transport._config;
        }
      }
    }
    return locales[name] = new Locale(mergeConfigs(parentConfig, config)), localeFamilies[name] && localeFamilies[name].forEach(function(x) {
      defineLocale(x.name, x.config);
    }), getSetGlobalLocale(name), locales[name];
  }
  /**
   * @param {number} key
   * @return {?}
   */
  function getLocale(key) {
    var locale;
    if (key && key._locale && key._locale._abbr && (key = key._locale._abbr), !key) {
      return globalLocale;
    }
    if (!isArray(key)) {
      if (locale = require(key)) {
        return locale;
      }
      /** @type {!Array} */
      key = [key];
    }
    return resolve(key);
  }
  /**
   * @param {!Object} m
   * @return {?}
   */
  function checkOverflow(m) {
    var overflow;
    var a = m._a;
    return a && -2 === getParsingFlags(m).overflow && (overflow = a[MONTH] < 0 || 11 < a[MONTH] ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || 24 < a[HOUR] || 24 === a[HOUR] && (0 !== a[SECOND] || 0 !== a[MINUTE] || 0 !== a[MILLISECOND]) ? HOUR : a[SECOND] < 0 || 59 < a[SECOND] ? SECOND : a[MINUTE] < 0 || 59 < a[MINUTE] ? MINUTE : a[MILLISECOND] < 0 || 999 < a[MILLISECOND] ? MILLISECOND : -1, getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || DATE < 
    overflow) && (overflow = DATE), getParsingFlags(m)._overflowWeeks && -1 === overflow && (overflow = WEEK), getParsingFlags(m)._overflowWeekday && -1 === overflow && (overflow = WEEKDAY), getParsingFlags(m).overflow = overflow), m;
  }
  /**
   * @param {!Object} config
   * @return {?}
   */
  function configFromISO(config) {
    var i;
    var tableslen;
    var dontAddBase;
    var dateFormat;
    var timeFormat;
    var tzFormat;
    var string = config._i;
    /** @type {(Array<string>|null)} */
    var lines = leadingTextRegExp.exec(string) || reLine.exec(string);
    if (lines) {
      /** @type {boolean} */
      getParsingFlags(config).iso = true;
      /** @type {number} */
      i = 0;
      /** @type {number} */
      tableslen = tables.length;
      for (; i < tableslen; i++) {
        if (tables[i][1].exec(lines[1])) {
          dateFormat = tables[i][0];
          /** @type {boolean} */
          dontAddBase = false !== tables[i][2];
          break;
        }
      }
      if (null == dateFormat) {
        return void(config._isValid = false);
      }
      if (lines[3]) {
        /** @type {number} */
        i = 0;
        /** @type {number} */
        tableslen = onCompleteBindings.length;
        for (; i < tableslen; i++) {
          if (onCompleteBindings[i][1].exec(lines[3])) {
            timeFormat = (lines[2] || " ") + onCompleteBindings[i][0];
            break;
          }
        }
        if (null == timeFormat) {
          return void(config._isValid = false);
        }
      }
      if (!dontAddBase && null != timeFormat) {
        return void(config._isValid = false);
      }
      if (lines[4]) {
        if (!moveRegex.exec(lines[4])) {
          return void(config._isValid = false);
        }
        /** @type {string} */
        tzFormat = "Z";
      }
      /** @type {string} */
      config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
      configFromStringAndFormat(config);
    } else {
      /** @type {boolean} */
      config._isValid = false;
    }
  }
  /**
   * @param {string} x
   * @param {string} s
   * @param {string} n
   * @param {string} children
   * @param {string} e
   * @param {string} text
   * @return {?}
   */
  function h(x, s, n, children, e, text) {
    /** @type {!Array} */
    var t = [function(n) {
      /** @type {number} */
      var x = parseInt(n, 10);
      {
        if (x <= 49) {
          return 2E3 + x;
        }
        if (x <= 999) {
          return 1900 + x;
        }
      }
      return x;
    }(x), monthsShort.indexOf(s), parseInt(n, 10), parseInt(children, 10), parseInt(e, 10)];
    return text && t.push(parseInt(text, 10)), t;
  }
  /**
   * @param {!Object} config
   * @return {undefined}
   */
  function configFromRFC2822(config) {
    var a;
    var o;
    var d;
    var conf;
    /** @type {(Array<string>|null)} */
    var arr = filename_pttrn.exec(config._i.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));
    if (arr) {
      if (a = h(arr[4], arr[3], arr[2], arr[5], arr[6], arr[7]), o = arr[1], d = a, conf = config, o && weekdays.indexOf(o) !== (new Date(d[0], d[1], d[2])).getDay() && (getParsingFlags(conf).weekdayMismatch = true, !void(conf._isValid = false))) {
        return;
      }
      config._a = a;
      config._tzm = function(wikiId, canCreateDiscussions, n) {
        if (wikiId) {
          return subwikiListsCache[wikiId];
        }
        if (canCreateDiscussions) {
          return 0;
        }
        /** @type {number} */
        var state = parseInt(n, 10);
        /** @type {number} */
        var pointer_state = state % 100;
        return 60 * ((state - pointer_state) / 100) + pointer_state;
      }(arr[8], arr[9], arr[10]);
      config._d = createUTCDate.apply(null, config._a);
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      /** @type {boolean} */
      getParsingFlags(config).rfc2822 = true;
    } else {
      /** @type {boolean} */
      config._isValid = false;
    }
  }
  /**
   * @param {?} path
   * @param {?} name
   * @param {?} handler
   * @return {?}
   */
  function defaults(path, name, handler) {
    return null != path ? path : null != name ? name : handler;
  }
  /**
   * @param {!Object} config
   * @return {undefined}
   */
  function configFromArray(config) {
    var i;
    var date;
    var currentDate;
    var deleted;
    var yearToUse;
    var c;
    var dt;
    /** @type {!Array} */
    var input = [];
    if (!config._d) {
      /** @type {!Object} */
      c = config;
      /** @type {!Date} */
      dt = new Date(hooks.now());
      /** @type {!Array} */
      currentDate = c._useUTC ? [dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate()] : [dt.getFullYear(), dt.getMonth(), dt.getDate()];
      if (config._w && null == config._a[DATE] && null == config._a[MONTH]) {
        (function(config) {
          var w;
          var weekYear;
          var week;
          var weekday;
          var dow;
          var doy;
          var temp;
          var u;
          var curWeek;
          if (null != (w = config._w).GG || null != w.W || null != w.E) {
            /** @type {number} */
            dow = 1;
            /** @type {number} */
            doy = 4;
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            if ((weekday = defaults(w.E, 1)) < 1 || 7 < weekday) {
              /** @type {boolean} */
              u = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
            week = defaults(w.w, curWeek.week);
            if (null != w.d) {
              if ((weekday = w.d) < 0 || 6 < weekday) {
                /** @type {boolean} */
                u = true;
              }
            } else {
              if (null != w.e) {
                weekday = w.e + dow;
                if (w.e < 0 || 6 < w.e) {
                  /** @type {boolean} */
                  u = true;
                }
              } else {
                weekday = dow;
              }
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            /** @type {boolean} */
            getParsingFlags(config)._overflowWeeks = true;
          } else {
            if (null != u) {
              /** @type {boolean} */
              getParsingFlags(config)._overflowWeekday = true;
            } else {
              temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
              config._a[YEAR] = temp.year;
              config._dayOfYear = temp.dayOfYear;
            }
          }
        })(config);
      }
      if (null != config._dayOfYear) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse) || 0 === config._dayOfYear) {
          /** @type {boolean} */
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      }
      /** @type {number} */
      i = 0;
      for (; i < 3 && null == config._a[i]; ++i) {
        config._a[i] = input[i] = currentDate[i];
      }
      for (; i < 7; i++) {
        config._a[i] = input[i] = null == config._a[i] ? 2 === i ? 1 : 0 : config._a[i];
      }
      if (24 === config._a[HOUR] && 0 === config._a[SECOND] && 0 === config._a[MINUTE] && 0 === config._a[MILLISECOND]) {
        /** @type {boolean} */
        config._nextDay = true;
        /** @type {number} */
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : function(y, i, d, hour, minute, s, ms) {
        var date;
        return y < 100 && 0 <= y ? (date = new Date(y + 400, i, d, hour, minute, s, ms), isFinite(date.getFullYear()) && date.setFullYear(y)) : date = new Date(y, i, d, hour, minute, s, ms), date;
      }).apply(null, input);
      deleted = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
      if (null != config._tzm) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        /** @type {number} */
        config._a[HOUR] = 24;
      }
      if (config._w && void 0 !== config._w.d && config._w.d !== deleted) {
        /** @type {boolean} */
        getParsingFlags(config).weekdayMismatch = true;
      }
    }
  }
  /**
   * @param {!Object} config
   * @return {undefined}
   */
  function configFromStringAndFormat(config) {
    if (config._f !== hooks.ISO_8601) {
      if (config._f !== hooks.RFC_2822) {
        /** @type {!Array} */
        config._a = [];
        /** @type {boolean} */
        getParsingFlags(config).empty = true;
        var parsedInput;
        var match;
        var groups;
        var t;
        var token;
        var input;
        var value;
        /** @type {string} */
        var string = "" + config._i;
        /** @type {number} */
        var stringLength = string.length;
        /** @type {number} */
        var totalParsedInputLength = 0;
        var marks = expandFormat(config._f, config._locale).match(separator) || [];
        /** @type {number} */
        var i = 0;
        for (; i < marks.length; i++) {
          match = marks[i];
          if (parsedInput = (string.match(getParseRegexForToken(match, config)) || [])[0]) {
            if (0 < (groups = string.substr(0, string.indexOf(parsedInput))).length) {
              getParsingFlags(config).unusedInput.push(groups);
            }
            /** @type {string} */
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength = totalParsedInputLength + parsedInput.length;
          }
          if (formatTokenFunctions[match]) {
            if (parsedInput) {
              /** @type {boolean} */
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(match);
            }
            token = match;
            /** @type {!Object} */
            value = config;
            if (null != (input = parsedInput) && hasOwnProp(tokens, token)) {
              tokens[token](input, value._a, value, token);
            }
          } else {
            if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(match);
            }
          }
        }
        /** @type {number} */
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (0 < string.length) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && true === getParsingFlags(config).bigHour && 0 < config._a[HOUR]) {
          getParsingFlags(config).bigHour = void 0;
        }
        /** @type {!Array<?>} */
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = function(locale, value, meridiem) {
          var needsProperty;
          if (null == meridiem) {
            return value;
          }
          return null != locale.meridiemHour ? locale.meridiemHour(value, meridiem) : (null != locale.isPM && ((needsProperty = locale.isPM(meridiem)) && value < 12 && (value = value + 12), needsProperty || 12 !== value || (value = 0)), value);
        }(config._locale, config._a[HOUR], config._meridiem);
        if (null !== (t = getParsingFlags(config).era)) {
          config._a[YEAR] = config._locale.erasConvertYear(t, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      } else {
        configFromRFC2822(config);
      }
    } else {
      configFromISO(config);
    }
  }
  /**
   * @param {!Object} config
   * @return {?}
   */
  function parse(config) {
    var data;
    var key;
    var input = config._i;
    var value = config._f;
    return config._locale = config._locale || getLocale(config._l), null === input || void 0 === value && "" === input ? createInvalid({
      nullInput : true
    }) : ("string" == typeof input && (config._i = input = config._locale.preparse(input)), isMoment(input) ? new Moment(checkOverflow(input)) : (isDate(input) ? config._d = input : isArray(value) ? function(config) {
      var tempConfig;
      var bestMoment;
      var scoreToBeat;
      var i;
      var currentScore;
      var a;
      /** @type {boolean} */
      var o = false;
      if (0 === config._f.length) {
        return getParsingFlags(config).invalidFormat = true, config._d = new Date(NaN);
      }
      /** @type {number} */
      i = 0;
      for (; i < config._f.length; i++) {
        /** @type {number} */
        currentScore = 0;
        /** @type {boolean} */
        a = false;
        tempConfig = copyConfig({}, config);
        if (null != config._useUTC) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);
        if (isValid(tempConfig)) {
          /** @type {boolean} */
          a = true;
        }
        currentScore = currentScore + getParsingFlags(tempConfig).charsLeftOver;
        currentScore = currentScore + 10 * getParsingFlags(tempConfig).unusedTokens.length;
        getParsingFlags(tempConfig).score = currentScore;
        if (o) {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        } else {
          if (null == scoreToBeat || currentScore < scoreToBeat || a) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (a) {
              /** @type {boolean} */
              o = true;
            }
          }
        }
      }
      extend(config, bestMoment || tempConfig);
    }(config) : value ? configFromStringAndFormat(config) : isUndefined(key = (data = config)._i) ? data._d = new Date(hooks.now()) : isDate(key) ? data._d = new Date(key.valueOf()) : "string" == typeof key ? function(config) {
      /** @type {(Array<string>|null)} */
      var t = aspNetJsonRegex.exec(config._i);
      if (null === t) {
        configFromISO(config);
        if (false === config._isValid) {
          delete config._isValid;
          configFromRFC2822(config);
          if (false === config._isValid) {
            delete config._isValid;
            if (config._strict) {
              /** @type {boolean} */
              config._isValid = false;
            } else {
              hooks.createFromInputFallback(config);
            }
          }
        }
      } else {
        /** @type {!Date} */
        config._d = new Date(+t[1]);
      }
    }(data) : isArray(key) ? (data._a = merge(key.slice(0), function(id_local) {
      return parseInt(id_local, 10);
    }), configFromArray(data)) : isObject(key) ? function(config) {
      var normalizedInput;
      var c;
      if (!config._d) {
        c = void 0 === (normalizedInput = normalizeObjectUnits(config._i)).day ? normalizedInput.date : normalizedInput.day;
        config._a = merge([normalizedInput.year, normalizedInput.month, c, normalizedInput.hour, normalizedInput.minute, normalizedInput.second, normalizedInput.millisecond], function(start) {
          return start && parseInt(start, 10);
        });
        configFromArray(config);
      }
    }(data) : isNumber(key) ? data._d = new Date(key) : hooks.createFromInputFallback(data), isValid(config) || (config._d = null), config));
  }
  /**
   * @param {!Object} input
   * @param {!Object} format
   * @param {!Object} locale
   * @param {!Object} strict
   * @param {boolean} isUTC
   * @return {?}
   */
  function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var res;
    var c = {};
    return true !== format && false !== format || (strict = format, format = void 0), true !== locale && false !== locale || (strict = locale, locale = void 0), (isObject(input) && isEmpty(input) || isArray(input) && 0 === input.length) && (input = void 0), c._isAMomentObject = true, c._useUTC = c._isUTC = isUTC, c._l = locale, c._i = input, c._f = format, c._strict = strict, (res = new Moment(checkOverflow(parse(c))))._nextDay && (res.add(1, "d"), res._nextDay = void 0), res;
  }
  /**
   * @param {!Object} input
   * @param {!Object} format
   * @param {!Object} locale
   * @param {!Object} strict
   * @return {?}
   */
  function createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
  }
  /**
   * @param {string} fn
   * @param {!Object} moments
   * @return {?}
   */
  function pickBy(fn, moments) {
    var res;
    var i;
    if (1 === moments.length && isArray(moments[0]) && (moments = moments[0]), !moments.length) {
      return createLocal();
    }
    res = moments[0];
    /** @type {number} */
    i = 1;
    for (; i < moments.length; ++i) {
      if (!(moments[i].isValid() && !moments[i][fn](res))) {
        res = moments[i];
      }
    }
    return res;
  }
  /**
   * @param {!Object} duration
   * @return {undefined}
   */
  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration);
    var n = normalizedInput.year || 0;
    var isAdding = normalizedInput.quarter || 0;
    var mom = normalizedInput.month || 0;
    var _oneDayInMilliseconds = normalizedInput.week || normalizedInput.isoWeek || 0;
    var _now = normalizedInput.day || 0;
    var o = normalizedInput.hour || 0;
    var u = normalizedInput.minute || 0;
    var _dim = normalizedInput.second || 0;
    var _pos = normalizedInput.millisecond || 0;
    this._isValid = function(m) {
      var k;
      var i;
      /** @type {boolean} */
      var s = false;
      for (k in m) {
        if (hasOwnProp(m, k) && (-1 === indexOf$1.call(ordering, k) || null != m[k] && isNaN(m[k]))) {
          return false;
        }
      }
      /** @type {number} */
      i = 0;
      for (; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
          if (s) {
            return false;
          }
          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            /** @type {boolean} */
            s = true;
          }
        }
      }
      return true;
    }(normalizedInput);
    /** @type {number} */
    this._milliseconds = +_pos + 1E3 * _dim + 6E4 * u + 1E3 * o * 60 * 60;
    /** @type {number} */
    this._days = +_now + 7 * _oneDayInMilliseconds;
    /** @type {number} */
    this._months = +mom + 3 * isAdding + 12 * n;
    this._data = {};
    this._locale = getLocale();
    this._bubble();
  }
  /**
   * @param {!Object} value
   * @return {?}
   */
  function isDuration(value) {
    return value instanceof Duration;
  }
  /**
   * @param {number} number
   * @return {?}
   */
  function absRound(number) {
    return number < 0 ? -1 * Math.round(-1 * number) : Math.round(number);
  }
  /**
   * @param {string} token
   * @param {string} separator
   * @return {undefined}
   */
  function offset(token, separator) {
    addFormatToken(token, 0, 0, function() {
      var offset = this.utcOffset();
      /** @type {string} */
      var sign = "+";
      return offset < 0 && (offset = -offset, sign = "-"), sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
    });
  }
  /**
   * @param {!RegExp} regex
   * @param {string} string
   * @return {?}
   */
  function offsetFromString(regex, string) {
    var match;
    var s;
    var tagSplit = (string || "").match(regex);
    return null === tagSplit ? null : 0 === (s = 60 * (match = ((tagSplit[tagSplit.length - 1] || []) + "").match(parseTimezoneChunker) || ["-", 0, 0])[1] + toInt(match[2])) ? 0 : "+" === match[0] ? s : -s;
  }
  /**
   * @param {?} input
   * @param {?} model
   * @return {?}
   */
  function cloneWithOffset(input, model) {
    var res;
    var offset;
    return model._isUTC ? (res = model.clone(), offset = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(), res._d.setTime(res._d.valueOf() + offset), hooks.updateOffset(res, false), res) : createLocal(input).local();
  }
  /**
   * @param {!Function} m
   * @return {?}
   */
  function getDateOffset(m) {
    return -Math.round(m._d.getTimezoneOffset());
  }
  /**
   * @return {?}
   */
  function isUtc() {
    return !!this.isValid() && (this._isUTC && 0 === this._offset);
  }
  /**
   * @param {!Object} input
   * @param {string} key
   * @return {?}
   */
  function createDuration(input, key) {
    var sign;
    var ret;
    var diffRes;
    /** @type {!Object} */
    var duration = input;
    /** @type {null} */
    var match = null;
    return isDuration(input) ? duration = {
      ms : input._milliseconds,
      d : input._days,
      M : input._months
    } : isNumber(input) || !isNaN(+input) ? (duration = {}, key ? duration[key] = +input : duration.milliseconds = +input) : (match = doctypeRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, duration = {
      y : 0,
      d : toInt(match[DATE]) * sign,
      h : toInt(match[HOUR]) * sign,
      m : toInt(match[SECOND]) * sign,
      s : toInt(match[MINUTE]) * sign,
      ms : toInt(absRound(1E3 * match[MILLISECOND])) * sign
    }) : (match = linePat.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, duration = {
      y : parseIso(match[2], sign),
      M : parseIso(match[3], sign),
      w : parseIso(match[4], sign),
      d : parseIso(match[5], sign),
      h : parseIso(match[6], sign),
      m : parseIso(match[7], sign),
      s : parseIso(match[8], sign)
    }) : null == duration ? duration = {} : "object" == typeof duration && ("from" in duration || "to" in duration) && (diffRes = function(base, other) {
      var res;
      if (!base.isValid() || !other.isValid()) {
        return {
          milliseconds : 0,
          months : 0
        };
      }
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        /** @type {number} */
        (res = positiveMomentsDifference(other, base)).milliseconds = -res.milliseconds;
        /** @type {number} */
        res.months = -res.months;
      }
      return res;
    }(createLocal(duration.from), createLocal(duration.to)), (duration = {}).ms = diffRes.milliseconds, duration.M = diffRes.months), ret = new Duration(duration), isDuration(input) && hasOwnProp(input, "_locale") && (ret._locale = input._locale), isDuration(input) && hasOwnProp(input, "_isValid") && (ret._isValid = input._isValid), ret;
  }
  /**
   * @param {string} inp
   * @param {!Object} sign
   * @return {?}
   */
  function parseIso(inp, sign) {
    var res = inp && parseFloat(inp.replace(",", "."));
    return (isNaN(res) ? 0 : res) * sign;
  }
  /**
   * @param {!Object} base
   * @param {!Object} other
   * @return {?}
   */
  function positiveMomentsDifference(base, other) {
    var th = {};
    return th.months = other.month() - base.month() + 12 * (other.year() - base.year()), base.clone().add(th.months, "M").isAfter(other) && --th.months, th.milliseconds = other - base.clone().add(th.months, "M"), th;
  }
  /**
   * @param {number} direction
   * @param {string} name
   * @return {?}
   */
  function createAdder(direction, name) {
    return function(val, value) {
      var test_value;
      return null === value || isNaN(+value) || (deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), test_value = val, val = value, value = test_value), addSubtract(this, createDuration(val, value), direction), this;
    };
  }
  /**
   * @param {!Object} mom
   * @param {!Object} duration
   * @param {number} isAdding
   * @param {string} updateOffset
   * @return {undefined}
   */
  function addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds;
    var days = absRound(duration._days);
    var months = absRound(duration._months);
    if (mom.isValid()) {
      updateOffset = null == updateOffset || updateOffset;
      if (months) {
        setMonth(mom, get(mom, "Month") + months * isAdding);
      }
      if (days) {
        set(mom, "Date", get(mom, "Date") + days * isAdding);
      }
      if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
      }
      if (updateOffset) {
        hooks.updateOffset(mom, days || months);
      }
    }
  }
  /**
   * @param {!Object} uri
   * @return {?}
   */
  function encodeURIComponent(uri) {
    return "string" == typeof uri || uri instanceof String;
  }
  /**
   * @param {!Object} input
   * @return {?}
   */
  function init(input) {
    return isMoment(input) || isDate(input) || encodeURIComponent(input) || isNumber(input) || function(a) {
      var aArray = isArray(a);
      /** @type {boolean} */
      var bArray = false;
      if (aArray) {
        /** @type {boolean} */
        bArray = 0 === a.filter(function(minWorkers) {
          return !isNumber(minWorkers) && encodeURIComponent(a);
        }).length;
      }
      return aArray && bArray;
    }(input) || function(x) {
      var i;
      var token;
      var relative = isObject(x) && !isEmpty(x);
      /** @type {boolean} */
      var point = false;
      /** @type {!Array} */
      var units = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"];
      /** @type {number} */
      i = 0;
      for (; i < units.length; i = i + 1) {
        token = units[i];
        point = point || hasOwnProp(x, token);
      }
      return relative && point;
    }(input) || null == input;
  }
  /**
   * @param {!Object} a
   * @param {!Object} b
   * @return {?}
   */
  function create(a, b) {
    if (a.date() < b.date()) {
      return -create(b, a);
    }
    /** @type {number} */
    var wholeMonthDiff = 12 * (b.year() - a.year()) + (b.month() - a.month());
    var anchor = a.clone().add(wholeMonthDiff, "months");
    /** @type {number} */
    var adjust = b - anchor < 0 ? (b - anchor) / (anchor - a.clone().add(wholeMonthDiff - 1, "months")) : (b - anchor) / (a.clone().add(1 + wholeMonthDiff, "months") - anchor);
    return -(wholeMonthDiff + adjust) || 0;
  }
  /**
   * @param {?} key
   * @return {?}
   */
  function locale(key) {
    var newLocaleData;
    return void 0 === key ? this._locale._abbr : (null != (newLocaleData = getLocale(key)) && (this._locale = newLocaleData), this);
  }
  /**
   * @return {?}
   */
  function localeData() {
    return this._locale;
  }
  /**
   * @param {number} x
   * @param {number} n
   * @return {?}
   */
  function floor(x, n) {
    return (x % n + n) % n;
  }
  /**
   * @param {number} year
   * @param {number} month
   * @param {number} date
   * @return {?}
   */
  function next(year, month, date) {
    return year < 100 && 0 <= year ? new Date(year + 400, month, date) - ofs : (new Date(year, month, date)).valueOf();
  }
  /**
   * @param {number} year
   * @param {number} month
   * @param {number} day
   * @return {?}
   */
  function serializeUTCDate(year, month, day) {
    return year < 100 && 0 <= year ? Date.UTC(year + 400, month, day) - ofs : Date.UTC(year, month, day);
  }
  /**
   * @param {?} message
   * @param {?} node
   * @return {?}
   */
  function matchSigned(message, node) {
    return node.erasAbbrRegex(message);
  }
  /**
   * @return {undefined}
   */
  function oldFinder() {
    /** @type {!Array} */
    var responseGroup = [];
    /** @type {!Array} */
    var outChance = [];
    /** @type {!Array} */
    var jointkey = [];
    /** @type {!Array} */
    var drilldownLevelLabels = [];
    var enums = this.eras();
    /** @type {number} */
    var i = 0;
    var t = enums.length;
    for (; i < t; ++i) {
      outChance.push(regexEscape(enums[i].name));
      responseGroup.push(regexEscape(enums[i].abbr));
      jointkey.push(regexEscape(enums[i].narrow));
      drilldownLevelLabels.push(regexEscape(enums[i].name));
      drilldownLevelLabels.push(regexEscape(enums[i].abbr));
      drilldownLevelLabels.push(regexEscape(enums[i].narrow));
    }
    /** @type {!RegExp} */
    this._erasRegex = new RegExp("^(" + drilldownLevelLabels.join("|") + ")", "i");
    /** @type {!RegExp} */
    this._erasNameRegex = new RegExp("^(" + outChance.join("|") + ")", "i");
    /** @type {!RegExp} */
    this._erasAbbrRegex = new RegExp("^(" + responseGroup.join("|") + ")", "i");
    /** @type {!RegExp} */
    this._erasNarrowRegex = new RegExp("^(" + jointkey.join("|") + ")", "i");
  }
  /**
   * @param {string} token
   * @param {string} getter
   * @return {undefined}
   */
  function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
  }
  /**
   * @param {number} input
   * @param {!Array} week
   * @param {?} weekday
   * @param {undefined} dow
   * @param {undefined} doy
   * @return {?}
   */
  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    return null == input ? weekOfYear(this, dow, doy).year : ((weeksTarget = weeksInYear(input, dow, doy)) < week && (week = weeksTarget), function(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
      var date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      return this.year(date.getUTCFullYear()), this.month(date.getUTCMonth()), this.date(date.getUTCDate()), this;
    }.call(this, input, week, weekday, dow, doy));
  }
  /**
   * @param {string} input
   * @param {!NodeList} array
   * @return {undefined}
   */
  function parseMs(input, array) {
    array[MILLISECOND] = toInt(1E3 * ("0." + input));
  }
  /**
   * @param {!Object} string
   * @return {?}
   */
  function preParsePostFormat(string) {
    return string;
  }
  /**
   * @param {string} format
   * @param {!Function} index
   * @param {string} field
   * @param {string} setter
   * @return {?}
   */
  function get$1(format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
  }
  /**
   * @param {string} format
   * @param {!Object} index
   * @param {string} field
   * @return {?}
   */
  function listMonthsImpl(format, index, field) {
    if (isNumber(format) && (index = format, format = void 0), format = format || "", null != index) {
      return get$1(format, index, field, "month");
    }
    /** @type {!Array} */
    var out = [];
    /** @type {number} */
    var i = 0;
    for (; i < 12; i++) {
      out[i] = get$1(format, i, field, "month");
    }
    return out;
  }
  /**
   * @param {string} value
   * @param {string} format
   * @param {string} index
   * @param {string} field
   * @return {?}
   */
  function listWeekdaysImpl(value, format, index, field) {
    format = ("boolean" == typeof value ? isNumber(format) && (index = format, format = void 0) : (format = value, value = false, isNumber(index = format) && (index = format, format = void 0)), format || "");
    var i;
    var locale = getLocale();
    var count = value ? locale._week.dow : 0;
    /** @type {!Array} */
    var out = [];
    if (null != index) {
      return get$1(format, (index + count) % 7, field, "day");
    }
    /** @type {number} */
    i = 0;
    for (; i < 7; i++) {
      out[i] = get$1(format, (i + count) % 7, field, "day");
    }
    return out;
  }
  /**
   * @param {!Object} duration
   * @param {?} input
   * @param {string} value
   * @param {number} direction
   * @return {?}
   */
  function addSubtract$1(duration, input, value, direction) {
    var other = createDuration(input, value);
    return duration._milliseconds += direction * other._milliseconds, duration._days += direction * other._days, duration._months += direction * other._months, duration._bubble();
  }
  /**
   * @param {?} n
   * @return {?}
   */
  function absCeil(n) {
    return n < 0 ? Math.floor(n) : Math.ceil(n);
  }
  /**
   * @param {number} days
   * @return {?}
   */
  function daysToYears(days) {
    return 4800 * days / 146097;
  }
  /**
   * @param {number} months
   * @return {?}
   */
  function monthsToDays(months) {
    return 146097 * months / 4800;
  }
  /**
   * @param {string} alias
   * @return {?}
   */
  function makeAs(alias) {
    return function() {
      return this.as(alias);
    };
  }
  /**
   * @param {string} name
   * @return {?}
   */
  function makeGetter(name) {
    return function() {
      return this.isValid() ? this._data[name] : NaN;
    };
  }
  /**
   * @param {!Object} posNegDuration
   * @param {boolean} withoutSuffix
   * @param {!Object} thresholds
   * @param {!Object} locale
   * @return {?}
   */
  function relativeTime(posNegDuration, withoutSuffix, thresholds, locale) {
    var _ = createDuration(posNegDuration).abs();
    var seconds = round(_.as("s"));
    var minutes = round(_.as("m"));
    var hours = round(_.as("h"));
    var days = round(_.as("d"));
    var months = round(_.as("M"));
    var x = round(_.as("w"));
    var years = round(_.as("y"));
    /** @type {(Array|boolean)} */
    var args = (seconds <= thresholds.ss ? ["s", seconds] : seconds < thresholds.s && ["ss", seconds]) || minutes <= 1 && ["m"] || minutes < thresholds.m && ["mm", minutes] || hours <= 1 && ["h"] || hours < thresholds.h && ["hh", hours] || days <= 1 && ["d"] || days < thresholds.d && ["dd", days];
    return null != thresholds.w && (args = args || x <= 1 && ["w"] || x < thresholds.w && ["ww", x]), (args = args || months <= 1 && ["M"] || months < thresholds.M && ["MM", months] || years <= 1 && ["y"] || ["yy", years])[2] = withoutSuffix, args[3] = 0 < +posNegDuration, args[4] = locale, function(string, number, n, isFuture, locale) {
      return locale.relativeTime(number || 1, !!n, string, isFuture);
    }.apply(null, args);
  }
  /**
   * @param {number} num_queued
   * @return {?}
   */
  function abs$1(num_queued) {
    return (0 < num_queued) - (num_queued < 0) || +num_queued;
  }
  /**
   * @return {?}
   */
  function toISOString$1() {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    var minutes;
    var hours;
    var years;
    var t;
    var prefix;
    var y;
    var sign;
    var TLT;
    /** @type {number} */
    var seconds = iso_string__abs(this._milliseconds) / 1E3;
    /** @type {number} */
    var days = iso_string__abs(this._days);
    /** @type {number} */
    var months = iso_string__abs(this._months);
    var total = this.asSeconds();
    return total ? (minutes = absFloor(seconds / 60), hours = absFloor(minutes / 60), seconds = seconds % 60, minutes = minutes % 60, years = absFloor(months / 12), months = months % 12, t = seconds ? seconds.toFixed(3).replace(/\.?0+$/, "") : "", prefix = total < 0 ? "-" : "", y = abs$1(this._months) !== abs$1(total) ? "-" : "", sign = abs$1(this._days) !== abs$1(total) ? "-" : "", TLT = abs$1(this._milliseconds) !== abs$1(total) ? "-" : "", prefix + "P" + (years ? y + years + "Y" : "") + (months ? 
    y + months + "M" : "") + (days ? sign + days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? TLT + hours + "H" : "") + (minutes ? TLT + minutes + "M" : "") + (seconds ? TLT + t + "S" : "")) : "P0D";
  }
  var oldSetupComputes;
  var some$1;
  /** @type {!Function} */
  some$1 = Array.prototype.some ? Array.prototype.some : function(callback) {
    /** @type {!Object} */
    var self = Object(this);
    /** @type {number} */
    var cell_amount = self.length >>> 0;
    /** @type {number} */
    var i = 0;
    for (; i < cell_amount; i++) {
      if (i in self && callback.call(this, self[i], i, self)) {
        return true;
      }
    }
    return false;
  };
  /** @type {!Array} */
  var crossfilterable_layers = hooks.momentProperties = [];
  /** @type {boolean} */
  var t = false;
  var callback;
  var processedOptions = {};
  /** @type {boolean} */
  hooks.suppressDeprecationWarnings = false;
  /** @type {null} */
  hooks.deprecationHandler = null;
  /** @type {!Function} */
  callback = Object.keys ? Object.keys : function(b) {
    var k;
    /** @type {!Array} */
    var coordsParsed = [];
    for (k in b) {
      if (hasOwnProp(b, k)) {
        coordsParsed.push(k);
      }
    }
    return coordsParsed;
  };
  /** @type {!RegExp} */
  var separator = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
  /** @type {!RegExp} */
  var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
  var formatFunctions = {};
  var formatTokenFunctions = {};
  var aliases = {};
  var priorities = {};
  var regexes;
  /** @type {!RegExp} */
  var match3 = /\d/;
  /** @type {!RegExp} */
  var match6 = /\d\d/;
  /** @type {!RegExp} */
  var match1 = /\d{3}/;
  /** @type {!RegExp} */
  var match4 = /\d{4}/;
  /** @type {!RegExp} */
  var match2 = /[+-]?\d{6}/;
  /** @type {!RegExp} */
  var match1to2 = /\d\d?/;
  /** @type {!RegExp} */
  var match1to4 = /\d\d\d\d?/;
  /** @type {!RegExp} */
  var match1to6 = /\d\d\d\d\d\d?/;
  /** @type {!RegExp} */
  var matchUnsigned = /\d{1,3}/;
  /** @type {!RegExp} */
  var matchTimestamp = /\d{1,4}/;
  /** @type {!RegExp} */
  var match5to6 = /[+-]?\d{1,6}/;
  /** @type {!RegExp} */
  var match1to3 = /\d+/;
  /** @type {!RegExp} */
  var match3to4 = /[+-]?\d+/;
  /** @type {!RegExp} */
  var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
  /** @type {!RegExp} */
  var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
  /** @type {!RegExp} */
  var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
  regexes = {};
  var tokens = {};
  var indexOf$1;
  /** @type {number} */
  var YEAR = 0;
  /** @type {number} */
  var MONTH = 1;
  /** @type {number} */
  var DATE = 2;
  /** @type {number} */
  var HOUR = 3;
  /** @type {number} */
  var SECOND = 4;
  /** @type {number} */
  var MINUTE = 5;
  /** @type {number} */
  var MILLISECOND = 6;
  /** @type {number} */
  var WEEK = 7;
  /** @type {number} */
  var WEEKDAY = 8;
  /** @type {!Function} */
  indexOf$1 = Array.prototype.indexOf ? Array.prototype.indexOf : function(o) {
    /** @type {number} */
    var i = 0;
    for (; i < this.length; ++i) {
      if (this[i] === o) {
        return i;
      }
    }
    return -1;
  };
  addFormatToken("M", ["MM", 2], "Mo", function() {
    return this.month() + 1;
  });
  addFormatToken("MMM", 0, 0, function(format) {
    return this.localeData().monthsShort(this, format);
  });
  addFormatToken("MMMM", 0, 0, function(format) {
    return this.localeData().months(this, format);
  });
  addUnitAlias("month", "M");
  addUnitPriority("month", 8);
  addRegexToken("M", match1to2);
  addRegexToken("MM", match1to2, match6);
  addRegexToken("MMM", function(isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
  });
  addRegexToken("MMMM", function(isStrict, locale) {
    return locale.monthsRegex(isStrict);
  });
  addParseToken(["M", "MM"], function(begin, ResultArray) {
    /** @type {number} */
    ResultArray[MONTH] = toInt(begin) - 1;
  });
  addParseToken(["MMM", "MMMM"], function(input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    if (null != month) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  });
  /** @type {!Array<string>} */
  var defaultLocaleMonths = "Enero_Febrero_Marzo_Abril_Mayo_Junio_Julio_Agosto_Septiembre_Octubre_Noviembre_Diciembre".split("_");
  /** @type {!Array<string>} */
  var monthsShort = "Ene_Feb_Mar_Abr_May_Jun_Jul_Ago_Sep_Oct_Nov_Dic".split("_");
  /** @type {!RegExp} */
  var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
  /** @type {!RegExp} */
  var defaultMonthsShortRegex = matchWord;
  /** @type {!RegExp} */
  var defaultMonthsRegex = matchWord;
  addFormatToken("Y", 0, 0, function() {
    var y = this.year();
    return y <= 9999 ? zeroFill(y, 4) : "+" + y;
  });
  addFormatToken(0, ["YY", 2], 0, function() {
    return this.year() % 100;
  });
  addFormatToken(0, ["YYYY", 4], 0, "year");
  addFormatToken(0, ["YYYYY", 5], 0, "year");
  addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
  addUnitAlias("year", "y");
  addUnitPriority("year", 1);
  addRegexToken("Y", match3to4);
  addRegexToken("YY", match1to2, match6);
  addRegexToken("YYYY", matchTimestamp, match4);
  addRegexToken("YYYYY", match5to6, match2);
  addRegexToken("YYYYYY", match5to6, match2);
  addParseToken(["YYYYY", "YYYYYY"], YEAR);
  addParseToken("YYYY", function(input, ResultArray) {
    ResultArray[YEAR] = 2 === input.length ? hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken("YY", function(input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
  });
  addParseToken("Y", function(input, array) {
    /** @type {number} */
    array[YEAR] = parseInt(input, 10);
  });
  /**
   * @param {!Object} input
   * @return {?}
   */
  hooks.parseTwoDigitYear = function(input) {
    return toInt(input) + (68 < toInt(input) ? 1900 : 2E3);
  };
  var getSetYear = makeGetSet("FullYear", true);
  addFormatToken("w", ["ww", 2], "wo", "week");
  addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
  addUnitAlias("week", "w");
  addUnitAlias("isoWeek", "W");
  addUnitPriority("week", 5);
  addUnitPriority("isoWeek", 5);
  addRegexToken("w", match1to2);
  addRegexToken("ww", match1to2, match6);
  addRegexToken("W", match1to2);
  addRegexToken("WW", match1to2, match6);
  addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, n, s) {
    week[s.substr(0, 1)] = toInt(input);
  });
  addFormatToken("d", 0, "do", "day");
  addFormatToken("dd", 0, 0, function(format) {
    return this.localeData().weekdaysMin(this, format);
  });
  addFormatToken("ddd", 0, 0, function(format) {
    return this.localeData().weekdaysShort(this, format);
  });
  addFormatToken("dddd", 0, 0, function(format) {
    return this.localeData().weekdays(this, format);
  });
  addFormatToken("e", 0, 0, "weekday");
  addFormatToken("E", 0, 0, "isoWeekday");
  addUnitAlias("day", "d");
  addUnitAlias("weekday", "e");
  addUnitAlias("isoWeekday", "E");
  addUnitPriority("day", 11);
  addUnitPriority("weekday", 11);
  addUnitPriority("isoWeekday", 11);
  addRegexToken("d", match1to2);
  addRegexToken("e", match1to2);
  addRegexToken("E", match1to2);
  addRegexToken("dd", function(isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken("ddd", function(isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken("dddd", function(isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
  });
  addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    if (null != weekday) {
      week.d = weekday;
    } else {
      /** @type {!Object} */
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken(["d", "e", "E"], function(input, week, n, token) {
    week[token] = toInt(input);
  });
  /** @type {!Array<string>} */
  var defaultLocaleWeekdays = "Domingo_Lunes_Martes_Miercoles_Jueves_Viernes_Sabado".split("_");
  /** @type {!Array<string>} */
  var weekdays = "Dom_Lun_Mar_Mie_Jue_Vie_Sab".split("_");
  /** @type {!Array<string>} */
  var defaultLocaleWeekdaysMin = "Do_Lu_Ma_Mi_Ju_Vi_Sa".split("_");
  /** @type {!RegExp} */
  var defaultWeekdaysRegex = matchWord;
  /** @type {!RegExp} */
  var defaultWeekdaysShortRegex = matchWord;
  /** @type {!RegExp} */
  var defaultWeekdaysMinRegex = matchWord;
  addFormatToken("H", ["HH", 2], 0, "hour");
  addFormatToken("h", ["hh", 2], 0, hFormat);
  addFormatToken("k", ["kk", 2], 0, function() {
    return this.hours() || 24;
  });
  addFormatToken("hmm", 0, 0, function() {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });
  addFormatToken("hmmss", 0, 0, function() {
    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  addFormatToken("Hmm", 0, 0, function() {
    return "" + this.hours() + zeroFill(this.minutes(), 2);
  });
  addFormatToken("Hmmss", 0, 0, function() {
    return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  meridiem("a", true);
  meridiem("A", false);
  addUnitAlias("hour", "h");
  addUnitPriority("hour", 13);
  addRegexToken("a", matchMeridiem);
  addRegexToken("A", matchMeridiem);
  addRegexToken("H", match1to2);
  addRegexToken("h", match1to2);
  addRegexToken("k", match1to2);
  addRegexToken("HH", match1to2, match6);
  addRegexToken("hh", match1to2, match6);
  addRegexToken("kk", match1to2, match6);
  addRegexToken("hmm", match1to4);
  addRegexToken("hmmss", match1to6);
  addRegexToken("Hmm", match1to4);
  addRegexToken("Hmmss", match1to6);
  addParseToken(["H", "HH"], HOUR);
  addParseToken(["k", "kk"], function(input, array, n) {
    var kInput = toInt(input);
    array[HOUR] = 24 === kInput ? 0 : kInput;
  });
  addParseToken(["a", "A"], function(input, canCreateDiscussions, config) {
    config._isPm = config._locale.isPM(input);
    /** @type {string} */
    config._meridiem = input;
  });
  addParseToken(["h", "hh"], function(input, array, config) {
    array[HOUR] = toInt(input);
    /** @type {boolean} */
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("hmm", function(input, datePartArray, config) {
    /** @type {number} */
    var pos1 = input.length - 2;
    datePartArray[HOUR] = toInt(input.substr(0, pos1));
    datePartArray[SECOND] = toInt(input.substr(pos1));
    /** @type {boolean} */
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("hmmss", function(input, datePartArray, config) {
    /** @type {number} */
    var pos1 = input.length - 4;
    /** @type {number} */
    var pos2 = input.length - 2;
    datePartArray[HOUR] = toInt(input.substr(0, pos1));
    datePartArray[SECOND] = toInt(input.substr(pos1, 2));
    datePartArray[MINUTE] = toInt(input.substr(pos2));
    /** @type {boolean} */
    getParsingFlags(config).bigHour = true;
  });
  addParseToken("Hmm", function(input, datePartArray, n) {
    /** @type {number} */
    var pos1 = input.length - 2;
    datePartArray[HOUR] = toInt(input.substr(0, pos1));
    datePartArray[SECOND] = toInt(input.substr(pos1));
  });
  addParseToken("Hmmss", function(input, datePartArray, n) {
    /** @type {number} */
    var pos1 = input.length - 4;
    /** @type {number} */
    var pos2 = input.length - 2;
    datePartArray[HOUR] = toInt(input.substr(0, pos1));
    datePartArray[SECOND] = toInt(input.substr(pos1, 2));
    datePartArray[MINUTE] = toInt(input.substr(pos2));
  });
  var getSetHour = makeGetSet("Hours", true);
  var globalLocale;
  var baseConfig = {
    calendar : {
      sameDay : "[Today at] LT",
      nextDay : "[Tomorrow at] LT",
      nextWeek : "dddd [at] LT",
      lastDay : "[Yesterday at] LT",
      lastWeek : "[Last] dddd [at] LT",
      sameElse : "L"
    },
    longDateFormat : {
      LTS : "h:mm:ss A",
      LT : "h:mm A",
      L : "MM/DD/YYYY",
      LL : "MMMM D, YYYY",
      LLL : "MMMM D, YYYY h:mm A",
      LLLL : "dddd, MMMM D, YYYY h:mm A"
    },
    invalidDate : "Invalid date",
    ordinal : "%d",
    dayOfMonthOrdinalParse : /\d{1,2}/,
    relativeTime : {
      future : "in %s",
      past : "%s ago",
      s : "a few seconds",
      ss : "%d seconds",
      m : "a minute",
      mm : "%d minutes",
      h : "an hour",
      hh : "%d hours",
      d : "a day",
      dd : "%d days",
      w : "a week",
      ww : "%d weeks",
      M : "a month",
      MM : "%d months",
      y : "a year",
      yy : "%d years"
    },
    months : defaultLocaleMonths,
    monthsShort : monthsShort,
    week : {
      dow : 0,
      doy : 6
    },
    weekdays : defaultLocaleWeekdays,
    weekdaysMin : defaultLocaleWeekdaysMin,
    weekdaysShort : weekdays,
    meridiemParse : /[ap]\.?m?\.?/i
  };
  var locales = {};
  var localeFamilies = {};
  /** @type {!RegExp} */
  var leadingTextRegExp = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  /** @type {!RegExp} */
  var reLine = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  /** @type {!RegExp} */
  var moveRegex = /Z|[+-]\d\d(?::?\d\d)?/;
  /** @type {!Array} */
  var tables = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, false], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, false], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, false], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, false], ["YYYY", /\d{4}/, false]];
  /** @type {!Array} */
  var onCompleteBindings = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]];
  /** @type {!RegExp} */
  var aspNetJsonRegex = /^\/?Date\((-?\d+)/i;
  /** @type {!RegExp} */
  var filename_pttrn = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
  var subwikiListsCache = {
    UT : 0,
    GMT : 0,
    EDT : -240,
    EST : -300,
    CDT : -300,
    CST : -360,
    MDT : -360,
    MST : -420,
    PDT : -420,
    PST : -480
  };
  hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
    /** @type {!Date} */
    config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
  });
  /**
   * @return {undefined}
   */
  hooks.ISO_8601 = function() {
  };
  /**
   * @return {undefined}
   */
  hooks.RFC_2822 = function() {
  };
  var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
    var e = createLocal.apply(null, arguments);
    return this.isValid() && e.isValid() ? e < this ? this : e : createInvalid();
  });
  var prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
    var e = createLocal.apply(null, arguments);
    return this.isValid() && e.isValid() ? this < e ? this : e : createInvalid();
  });
  /** @type {!Array} */
  var ordering = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
  offset("Z", ":");
  offset("ZZ", "");
  addRegexToken("Z", matchShortOffset);
  addRegexToken("ZZ", matchShortOffset);
  addParseToken(["Z", "ZZ"], function(input, canCreateDiscussions, config) {
    /** @type {boolean} */
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
  });
  /** @type {!RegExp} */
  var parseTimezoneChunker = /([\+\-]|\d\d)/gi;
  /**
   * @return {undefined}
   */
  hooks.updateOffset = function() {
  };
  /** @type {!RegExp} */
  var doctypeRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/;
  /** @type {!RegExp} */
  var linePat = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  createDuration.fn = Duration.prototype;
  /**
   * @return {?}
   */
  createDuration.invalid = function() {
    return createDuration(NaN);
  };
  var add = createAdder(1, "add");
  var subtract = createAdder(-1, "subtract");
  /** @type {string} */
  hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
  /** @type {string} */
  hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
  var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
    return void 0 === key ? this.localeData() : this.locale(key);
  });
  /** @type {number} */
  var ofs = 126227808E5;
  addFormatToken("N", 0, 0, "eraAbbr");
  addFormatToken("NN", 0, 0, "eraAbbr");
  addFormatToken("NNN", 0, 0, "eraAbbr");
  addFormatToken("NNNN", 0, 0, "eraName");
  addFormatToken("NNNNN", 0, 0, "eraNarrow");
  addFormatToken("y", ["y", 1], "yo", "eraYear");
  addFormatToken("y", ["yy", 2], 0, "eraYear");
  addFormatToken("y", ["yyy", 3], 0, "eraYear");
  addFormatToken("y", ["yyyy", 4], 0, "eraYear");
  addRegexToken("N", matchSigned);
  addRegexToken("NN", matchSigned);
  addRegexToken("NNN", matchSigned);
  addRegexToken("NNNN", function(e, PL$37) {
    return PL$37.erasNameRegex(e);
  });
  addRegexToken("NNNNN", function(e, PL$37) {
    return PL$37.erasNarrowRegex(e);
  });
  addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(e, canCreateDiscussions, config, s) {
    var value = config._locale.erasParse(e, s, config._strict);
    if (value) {
      getParsingFlags(config).era = value;
    } else {
      /** @type {string} */
      getParsingFlags(config).invalidEra = e;
    }
  });
  addRegexToken("y", match1to3);
  addRegexToken("yy", match1to3);
  addRegexToken("yyy", match1to3);
  addRegexToken("yyyy", match1to3);
  addRegexToken("yo", function(isSlidingUp, uploadFileTpl) {
    return uploadFileTpl._eraYearOrdinalRegex || match1to3;
  });
  addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
  addParseToken(["yo"], function(input, array, from, s) {
    var replaceStr;
    if (from._locale._eraYearOrdinalRegex) {
      replaceStr = input.match(from._locale._eraYearOrdinalRegex);
    }
    if (from._locale.eraYearOrdinalParse) {
      array[YEAR] = from._locale.eraYearOrdinalParse(input, replaceStr);
    } else {
      /** @type {number} */
      array[YEAR] = parseInt(input, 10);
    }
  });
  addFormatToken(0, ["gg", 2], 0, function() {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ["GG", 2], 0, function() {
    return this.isoWeekYear() % 100;
  });
  addWeekYearFormatToken("gggg", "weekYear");
  addWeekYearFormatToken("ggggg", "weekYear");
  addWeekYearFormatToken("GGGG", "isoWeekYear");
  addWeekYearFormatToken("GGGGG", "isoWeekYear");
  addUnitAlias("weekYear", "gg");
  addUnitAlias("isoWeekYear", "GG");
  addUnitPriority("weekYear", 1);
  addUnitPriority("isoWeekYear", 1);
  addRegexToken("G", match3to4);
  addRegexToken("g", match3to4);
  addRegexToken("GG", match1to2, match6);
  addRegexToken("gg", match1to2, match6);
  addRegexToken("GGGG", matchTimestamp, match4);
  addRegexToken("gggg", matchTimestamp, match4);
  addRegexToken("GGGGG", match5to6, match2);
  addRegexToken("ggggg", match5to6, match2);
  addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, n, s) {
    week[s.substr(0, 2)] = toInt(input);
  });
  addWeekParseToken(["gg", "GG"], function(input, week, n, token) {
    week[token] = hooks.parseTwoDigitYear(input);
  });
  addFormatToken("Q", 0, "Qo", "quarter");
  addUnitAlias("quarter", "Q");
  addUnitPriority("quarter", 7);
  addRegexToken("Q", match3);
  addParseToken("Q", function(begin, ResultArray) {
    /** @type {number} */
    ResultArray[MONTH] = 3 * (toInt(begin) - 1);
  });
  addFormatToken("D", ["DD", 2], "Do", "date");
  addUnitAlias("date", "D");
  addUnitPriority("date", 9);
  addRegexToken("D", match1to2);
  addRegexToken("DD", match1to2, match6);
  addRegexToken("Do", function(isStrict, locale) {
    return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
  });
  addParseToken(["D", "DD"], DATE);
  addParseToken("Do", function(input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
  });
  var getSetDayOfMonth = makeGetSet("Date", true);
  addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
  addUnitAlias("dayOfYear", "DDD");
  addUnitPriority("dayOfYear", 4);
  addRegexToken("DDD", matchUnsigned);
  addRegexToken("DDDD", match1);
  addParseToken(["DDD", "DDDD"], function(input, canCreateDiscussions, config) {
    config._dayOfYear = toInt(input);
  });
  addFormatToken("m", ["mm", 2], 0, "minute");
  addUnitAlias("minute", "m");
  addUnitPriority("minute", 14);
  addRegexToken("m", match1to2);
  addRegexToken("mm", match1to2, match6);
  addParseToken(["m", "mm"], SECOND);
  var getSetMinute = makeGetSet("Minutes", false);
  addFormatToken("s", ["ss", 2], 0, "second");
  addUnitAlias("second", "s");
  addUnitPriority("second", 15);
  addRegexToken("s", match1to2);
  addRegexToken("ss", match1to2, match6);
  addParseToken(["s", "ss"], MINUTE);
  var token;
  var getSetMillisecond;
  var getSetSecond = makeGetSet("Seconds", false);
  addFormatToken("S", 0, 0, function() {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ["SS", 2], 0, function() {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ["SSS", 3], 0, "millisecond");
  addFormatToken(0, ["SSSS", 4], 0, function() {
    return 10 * this.millisecond();
  });
  addFormatToken(0, ["SSSSS", 5], 0, function() {
    return 100 * this.millisecond();
  });
  addFormatToken(0, ["SSSSSS", 6], 0, function() {
    return 1E3 * this.millisecond();
  });
  addFormatToken(0, ["SSSSSSS", 7], 0, function() {
    return 1E4 * this.millisecond();
  });
  addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
    return 1E5 * this.millisecond();
  });
  addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
    return 1E6 * this.millisecond();
  });
  addUnitAlias("millisecond", "ms");
  addUnitPriority("millisecond", 16);
  addRegexToken("S", matchUnsigned, match3);
  addRegexToken("SS", matchUnsigned, match6);
  addRegexToken("SSS", matchUnsigned, match1);
  /** @type {string} */
  token = "SSSS";
  for (; token.length <= 9; token = token + "S") {
    addRegexToken(token, match1to3);
  }
  /** @type {string} */
  token = "S";
  for (; token.length <= 9; token = token + "S") {
    addParseToken(token, parseMs);
  }
  getSetMillisecond = makeGetSet("Milliseconds", false);
  addFormatToken("z", 0, 0, "zoneAbbr");
  addFormatToken("zz", 0, 0, "zoneName");
  var proto = Moment.prototype;
  proto.add = add;
  /**
   * @param {number} time
   * @param {!Object} formats
   * @return {?}
   */
  proto.calendar = function(time, formats) {
    if (1 === arguments.length) {
      if (arguments[0]) {
        if (init(arguments[0])) {
          time = arguments[0];
          formats = void 0;
        } else {
          if (function(b) {
            var ADVANCED_SEARCH_TYPEAHEAD = isObject(b) && !isEmpty(b);
            /** @type {boolean} */
            var suggestions = false;
            /** @type {!Array} */
            var props = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"];
            /** @type {number} */
            var i = 0;
            for (; i < props.length; i = i + 1) {
              suggestions = suggestions || hasOwnProp(b, props[i]);
            }
            return ADVANCED_SEARCH_TYPEAHEAD && suggestions;
          }(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
      } else {
        formats = time = void 0;
      }
    }
    var now = time || createLocal();
    var sod = cloneWithOffset(now, this).startOf("day");
    var format = hooks.calendarFormat(this, sod) || "sameElse";
    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
  };
  /**
   * @return {?}
   */
  proto.clone = function() {
    return new Moment(this);
  };
  /**
   * @param {?} input
   * @param {string} units
   * @param {boolean} asFloat
   * @return {?}
   */
  proto.diff = function(input, units, asFloat) {
    var a;
    var b;
    var result;
    if (!this.isValid()) {
      return NaN;
    }
    if (!(a = cloneWithOffset(input, this)).isValid()) {
      return NaN;
    }
    switch(b = 6E4 * (a.utcOffset() - this.utcOffset()), units = normalizeUnits(units)) {
      case "year":
        /** @type {number} */
        result = create(this, a) / 12;
        break;
      case "month":
        result = create(this, a);
        break;
      case "quarter":
        /** @type {number} */
        result = create(this, a) / 3;
        break;
      case "second":
        /** @type {number} */
        result = (this - a) / 1E3;
        break;
      case "minute":
        /** @type {number} */
        result = (this - a) / 6E4;
        break;
      case "hour":
        /** @type {number} */
        result = (this - a) / 36E5;
        break;
      case "day":
        /** @type {number} */
        result = (this - a - b) / 864E5;
        break;
      case "week":
        /** @type {number} */
        result = (this - a - b) / 6048E5;
        break;
      default:
        /** @type {number} */
        result = this - a;
    }
    return asFloat ? result : absFloor(result);
  };
  /**
   * @param {string} units
   * @return {?}
   */
  proto.endOf = function(units) {
    var x;
    var daysInMonth;
    if (void 0 === (units = normalizeUnits(units)) || "millisecond" === units || !this.isValid()) {
      return this;
    }
    switch(daysInMonth = this._isUTC ? serializeUTCDate : next, units) {
      case "year":
        /** @type {number} */
        x = daysInMonth(this.year() + 1, 0, 1) - 1;
        break;
      case "quarter":
        /** @type {number} */
        x = daysInMonth(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
        break;
      case "month":
        /** @type {number} */
        x = daysInMonth(this.year(), this.month() + 1, 1) - 1;
        break;
      case "week":
        /** @type {number} */
        x = daysInMonth(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
        break;
      case "isoWeek":
        /** @type {number} */
        x = daysInMonth(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
        break;
      case "day":
      case "date":
        /** @type {number} */
        x = daysInMonth(this.year(), this.month(), this.date() + 1) - 1;
        break;
      case "hour":
        x = this._d.valueOf();
        x = x + (36E5 - floor(x + (this._isUTC ? 0 : 6E4 * this.utcOffset()), 36E5) - 1);
        break;
      case "minute":
        x = this._d.valueOf();
        x = x + (6E4 - floor(x, 6E4) - 1);
        break;
      case "second":
        x = this._d.valueOf();
        x = x + (1E3 - floor(x, 1E3) - 1);
        break;
    }
    return this._d.setTime(x), hooks.updateOffset(this, true), this;
  };
  /**
   * @param {string} url
   * @return {?}
   */
  proto.format = function(url) {
    url = url || (this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat);
    var output = format(this, url);
    return this.localeData().postformat(output);
  };
  /**
   * @param {!Object} time
   * @param {?} withoutSuffix
   * @return {?}
   */
  proto.from = function(time, withoutSuffix) {
    return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
      to : this,
      from : time
    }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate();
  };
  /**
   * @param {?} withoutSuffix
   * @return {?}
   */
  proto.fromNow = function(withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
  };
  /**
   * @param {!Object} time
   * @param {?} withoutSuffix
   * @return {?}
   */
  proto.to = function(time, withoutSuffix) {
    return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
      from : this,
      to : time
    }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate();
  };
  /**
   * @param {?} withoutSuffix
   * @return {?}
   */
  proto.toNow = function(withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
  };
  /**
   * @param {string} units
   * @return {?}
   */
  proto.get = function(units) {
    return isFunction(this[units = normalizeUnits(units)]) ? this[units]() : this;
  };
  /**
   * @return {?}
   */
  proto.invalidAt = function() {
    return getParsingFlags(this).overflow;
  };
  /**
   * @param {!Object} input
   * @param {string} units
   * @return {?}
   */
  proto.isAfter = function(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    return !(!this.isValid() || !localInput.isValid()) && ("millisecond" === (units = normalizeUnits(units) || "millisecond") ? this.valueOf() > localInput.valueOf() : localInput.valueOf() < this.clone().startOf(units).valueOf());
  };
  /**
   * @param {!Object} input
   * @param {string} units
   * @return {?}
   */
  proto.isBefore = function(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    return !(!this.isValid() || !localInput.isValid()) && ("millisecond" === (units = normalizeUnits(units) || "millisecond") ? this.valueOf() < localInput.valueOf() : this.clone().endOf(units).valueOf() < localInput.valueOf());
  };
  /**
   * @param {!Object} input
   * @param {!Object} time
   * @param {string} units
   * @param {string} inclusivity
   * @return {?}
   */
  proto.isBetween = function(input, time, units, inclusivity) {
    var to = isMoment(input) ? input : createLocal(input);
    var other = isMoment(time) ? time : createLocal(time);
    return !!(this.isValid() && to.isValid() && other.isValid()) && (("(" === (inclusivity = inclusivity || "()")[0] ? this.isAfter(to, units) : !this.isBefore(to, units)) && (")" === inclusivity[1] ? this.isBefore(other, units) : !this.isAfter(other, units)));
  };
  /**
   * @param {!Object} input
   * @param {string} units
   * @return {?}
   */
  proto.isSame = function(input, units) {
    var n;
    var localInput = isMoment(input) ? input : createLocal(input);
    return !(!this.isValid() || !localInput.isValid()) && ("millisecond" === (units = normalizeUnits(units) || "millisecond") ? this.valueOf() === localInput.valueOf() : (n = localInput.valueOf(), this.clone().startOf(units).valueOf() <= n && n <= this.clone().endOf(units).valueOf()));
  };
  /**
   * @param {!Object} input
   * @param {string} units
   * @return {?}
   */
  proto.isSameOrAfter = function(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
  };
  /**
   * @param {!Object} input
   * @param {string} units
   * @return {?}
   */
  proto.isSameOrBefore = function(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
  };
  /**
   * @return {?}
   */
  proto.isValid = function() {
    return isValid(this);
  };
  proto.lang = lang;
  /** @type {function(?): ?} */
  proto.locale = locale;
  /** @type {function(): ?} */
  proto.localeData = localeData;
  proto.max = prototypeMax;
  proto.min = prototypeMin;
  /**
   * @return {?}
   */
  proto.parsingFlags = function() {
    return extend({}, getParsingFlags(this));
  };
  /**
   * @param {string} units
   * @param {!Function} value
   * @return {?}
   */
  proto.set = function(units, value) {
    if ("object" == typeof units) {
      var mp4Samples = function(regexes) {
        var i;
        /** @type {!Array} */
        var units = [];
        for (i in regexes) {
          if (hasOwnProp(regexes, i)) {
            units.push({
              unit : i,
              priority : priorities[i]
            });
          }
        }
        return units.sort(function(secondListenerDetails, firstListenerDetails) {
          return secondListenerDetails.priority - firstListenerDetails.priority;
        }), units;
      }(units = normalizeObjectUnits(units));
      /** @type {number} */
      var i = 0;
      for (; i < mp4Samples.length; i++) {
        this[mp4Samples[i].unit](units[mp4Samples[i].unit]);
      }
    } else {
      if (isFunction(this[units = normalizeUnits(units)])) {
        return this[units](value);
      }
    }
    return this;
  };
  /**
   * @param {string} units
   * @return {?}
   */
  proto.startOf = function(units) {
    var x;
    var toJalaali;
    if (void 0 === (units = normalizeUnits(units)) || "millisecond" === units || !this.isValid()) {
      return this;
    }
    switch(toJalaali = this._isUTC ? serializeUTCDate : next, units) {
      case "year":
        x = toJalaali(this.year(), 0, 1);
        break;
      case "quarter":
        x = toJalaali(this.year(), this.month() - this.month() % 3, 1);
        break;
      case "month":
        x = toJalaali(this.year(), this.month(), 1);
        break;
      case "week":
        x = toJalaali(this.year(), this.month(), this.date() - this.weekday());
        break;
      case "isoWeek":
        x = toJalaali(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
        break;
      case "day":
      case "date":
        x = toJalaali(this.year(), this.month(), this.date());
        break;
      case "hour":
        x = this._d.valueOf();
        /** @type {number} */
        x = x - floor(x + (this._isUTC ? 0 : 6E4 * this.utcOffset()), 36E5);
        break;
      case "minute":
        x = this._d.valueOf();
        /** @type {number} */
        x = x - floor(x, 6E4);
        break;
      case "second":
        x = this._d.valueOf();
        /** @type {number} */
        x = x - floor(x, 1E3);
        break;
    }
    return this._d.setTime(x), hooks.updateOffset(this, true), this;
  };
  proto.subtract = subtract;
  /**
   * @return {?}
   */
  proto.toArray = function() {
    var options = this;
    return [options.year(), options.month(), options.date(), options.hour(), options.minute(), options.second(), options.millisecond()];
  };
  /**
   * @return {?}
   */
  proto.toObject = function() {
    var TProto = this;
    return {
      years : TProto.year(),
      months : TProto.month(),
      date : TProto.date(),
      hours : TProto.hours(),
      minutes : TProto.minutes(),
      seconds : TProto.seconds(),
      milliseconds : TProto.milliseconds()
    };
  };
  /**
   * @return {?}
   */
  proto.toDate = function() {
    return new Date(this.valueOf());
  };
  /**
   * @param {boolean} genConfig
   * @return {?}
   */
  proto.toISOString = function(genConfig) {
    if (!this.isValid()) {
      return null;
    }
    /** @type {boolean} */
    var CMD_REQUIRES_CONFIG = true !== genConfig;
    var field = CMD_REQUIRES_CONFIG ? this.clone().utc() : this;
    return field.year() < 0 || 9999 < field.year() ? format(field, CMD_REQUIRES_CONFIG ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : isFunction(Date.prototype.toISOString) ? CMD_REQUIRES_CONFIG ? this.toDate().toISOString() : (new Date(this.valueOf() + 60 * this.utcOffset() * 1E3)).toISOString().replace("Z", format(field, "Z")) : format(field, CMD_REQUIRES_CONFIG ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
  };
  /**
   * @return {?}
   */
  proto.inspect = function() {
    if (!this.isValid()) {
      return "moment.invalid(/* " + this._i + " */)";
    }
    var permission_;
    var t;
    var suffix;
    /** @type {string} */
    var $c$ = "moment";
    /** @type {string} */
    var ch = "";
    return this.isLocal() || ($c$ = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", ch = "Z"), permission_ = "[" + $c$ + '("]', t = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", suffix = ch + '[")]', this.format(permission_ + t + "-MM-DD[T]HH:mm:ss.SSS" + suffix);
  };
  if ("undefined" != typeof Symbol && null != Symbol.for) {
    /**
     * @return {?}
     */
    proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return "Moment<" + this.format() + ">";
    };
  }
  /**
   * @return {?}
   */
  proto.toJSON = function() {
    return this.isValid() ? this.toISOString() : null;
  };
  /**
   * @return {?}
   */
  proto.toString = function() {
    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
  };
  /**
   * @return {?}
   */
  proto.unix = function() {
    return Math.floor(this.valueOf() / 1E3);
  };
  /**
   * @return {?}
   */
  proto.valueOf = function() {
    return this._d.valueOf() - 6E4 * (this._offset || 0);
  };
  /**
   * @return {?}
   */
  proto.creationData = function() {
    return {
      input : this._i,
      format : this._f,
      locale : this._locale,
      isUTC : this._isUTC,
      strict : this._strict
    };
  };
  /**
   * @return {?}
   */
  proto.eraName = function() {
    var now;
    var results = this.localeData().eras();
    /** @type {number} */
    var i = 0;
    var l = results.length;
    for (; i < l; ++i) {
      if (now = this.clone().startOf("day").valueOf(), results[i].since <= now && now <= results[i].until) {
        return results[i].name;
      }
      if (results[i].until <= now && now <= results[i].since) {
        return results[i].name;
      }
    }
    return "";
  };
  /**
   * @return {?}
   */
  proto.eraNarrow = function() {
    var now;
    var results = this.localeData().eras();
    /** @type {number} */
    var i = 0;
    var l = results.length;
    for (; i < l; ++i) {
      if (now = this.clone().startOf("day").valueOf(), results[i].since <= now && now <= results[i].until) {
        return results[i].narrow;
      }
      if (results[i].until <= now && now <= results[i].since) {
        return results[i].narrow;
      }
    }
    return "";
  };
  /**
   * @return {?}
   */
  proto.eraAbbr = function() {
    var now;
    var results = this.localeData().eras();
    /** @type {number} */
    var i = 0;
    var l = results.length;
    for (; i < l; ++i) {
      if (now = this.clone().startOf("day").valueOf(), results[i].since <= now && now <= results[i].until) {
        return results[i].abbr;
      }
      if (results[i].until <= now && now <= results[i].since) {
        return results[i].abbr;
      }
    }
    return "";
  };
  /**
   * @return {?}
   */
  proto.eraYear = function() {
    var byteIdx;
    var point;
    var results = this.localeData().eras();
    /** @type {number} */
    var i = 0;
    var l = results.length;
    for (; i < l; ++i) {
      if (byteIdx = results[i].since <= results[i].until ? 1 : -1, point = this.clone().startOf("day").valueOf(), results[i].since <= point && point <= results[i].until || results[i].until <= point && point <= results[i].since) {
        return (this.year() - hooks(results[i].since).year()) * byteIdx + results[i].offset;
      }
    }
    return this.year();
  };
  proto.year = getSetYear;
  /**
   * @return {?}
   */
  proto.isLeapYear = function() {
    return isLeapYear(this.year());
  };
  /**
   * @param {?} input
   * @return {?}
   */
  proto.weekYear = function(input) {
    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
  };
  /**
   * @param {?} input
   * @return {?}
   */
  proto.isoWeekYear = function(input) {
    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
  };
  /** @type {function(number): ?} */
  proto.quarter = proto.quarters = function(opt_value) {
    return null == opt_value ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (opt_value - 1) + this.month() % 3);
  };
  /** @type {function(number): ?} */
  proto.month = getSetMonth;
  /**
   * @return {?}
   */
  proto.daysInMonth = function() {
    return daysInMonth(this.year(), this.month());
  };
  /** @type {function(string): ?} */
  proto.week = proto.weeks = function(i) {
    var c = this.localeData().week(this);
    return null == i ? c : this.add(7 * (i - c), "d");
  };
  /** @type {function(string): ?} */
  proto.isoWeek = proto.isoWeeks = function(l) {
    var i = weekOfYear(this, 1, 4).week;
    return null == l ? i : this.add(7 * (l - i), "d");
  };
  /**
   * @return {?}
   */
  proto.weeksInYear = function() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  };
  /**
   * @return {?}
   */
  proto.weeksInWeekYear = function() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
  };
  /**
   * @return {?}
   */
  proto.isoWeeksInYear = function() {
    return weeksInYear(this.year(), 1, 4);
  };
  /**
   * @return {?}
   */
  proto.isoWeeksInISOWeekYear = function() {
    return weeksInYear(this.isoWeekYear(), 1, 4);
  };
  proto.date = getSetDayOfMonth;
  /** @type {function(string): ?} */
  proto.day = proto.days = function(input) {
    if (!this.isValid()) {
      return null != input ? this : NaN;
    }
    var a;
    var b;
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    return null != input ? (a = input, b = this.localeData(), input = "string" != typeof a ? a : isNaN(a) ? "number" == typeof(a = b.weekdaysParse(a)) ? a : null : parseInt(a, 10), this.add(input - day, "d")) : day;
  };
  /**
   * @param {string} input
   * @return {?}
   */
  proto.weekday = function(input) {
    if (!this.isValid()) {
      return null != input ? this : NaN;
    }
    /** @type {number} */
    var day = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return null == input ? day : this.add(input - day, "d");
  };
  /**
   * @param {number} input
   * @return {?}
   */
  proto.isoWeekday = function(input) {
    if (!this.isValid()) {
      return null != input ? this : NaN;
    }
    if (null == input) {
      return this.day() || 7;
    }
    var a;
    var b;
    var weekday = (a = input, b = this.localeData(), "string" == typeof a ? b.weekdaysParse(a) % 7 || 7 : isNaN(a) ? null : a);
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  };
  /**
   * @param {string} input
   * @return {?}
   */
  proto.dayOfYear = function(input) {
    /** @type {number} */
    var day = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864E5) + 1;
    return null == input ? day : this.add(input - day, "d");
  };
  proto.hour = proto.hours = getSetHour;
  proto.minute = proto.minutes = getSetMinute;
  proto.second = proto.seconds = getSetSecond;
  proto.millisecond = proto.milliseconds = getSetMillisecond;
  /**
   * @param {number} input
   * @param {string} keepLocalTime
   * @param {boolean} keepMinutes
   * @return {?}
   */
  proto.utcOffset = function(input, keepLocalTime, keepMinutes) {
    var localAdjust;
    var offset = this._offset || 0;
    if (!this.isValid()) {
      return null != input ? this : NaN;
    }
    if (null == input) {
      return this._isUTC ? offset : getDateOffset(this);
    }
    if ("string" == typeof input) {
      if (null === (input = offsetFromString(matchShortOffset, input))) {
        return this;
      }
    } else {
      if (Math.abs(input) < 16 && !keepMinutes) {
        /** @type {number} */
        input = input * 60;
      }
    }
    return !this._isUTC && keepLocalTime && (localAdjust = getDateOffset(this)), this._offset = input, this._isUTC = true, null != localAdjust && this.add(localAdjust, "m"), offset !== input && (!keepLocalTime || this._changeInProgress ? addSubtract(this, createDuration(input - offset, "m"), 1, false) : this._changeInProgress || (this._changeInProgress = true, hooks.updateOffset(this, true), this._changeInProgress = null)), this;
  };
  /**
   * @param {!Object} input
   * @return {?}
   */
  proto.utc = function(input) {
    return this.utcOffset(0, input);
  };
  /**
   * @param {string} keepLocalTime
   * @return {?}
   */
  proto.local = function(keepLocalTime) {
    return this._isUTC && (this.utcOffset(0, keepLocalTime), this._isUTC = false, keepLocalTime && this.subtract(getDateOffset(this), "m")), this;
  };
  /**
   * @return {?}
   */
  proto.parseZone = function() {
    var input;
    return null != this._tzm ? this.utcOffset(this._tzm, false, true) : "string" == typeof this._i && (null != (input = offsetFromString(matchOffset, this._i)) ? this.utcOffset(input) : this.utcOffset(0, true)), this;
  };
  /**
   * @param {!Array} input
   * @return {?}
   */
  proto.hasAlignedHourOffset = function(input) {
    return !!this.isValid() && (input = input ? createLocal(input).utcOffset() : 0, (this.utcOffset() - input) % 60 == 0);
  };
  /**
   * @return {?}
   */
  proto.isDST = function() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
  };
  /**
   * @return {?}
   */
  proto.isLocal = function() {
    return !!this.isValid() && !this._isUTC;
  };
  /**
   * @return {?}
   */
  proto.isUtcOffset = function() {
    return !!this.isValid() && this._isUTC;
  };
  /** @type {function(): ?} */
  proto.isUtc = isUtc;
  /** @type {function(): ?} */
  proto.isUTC = isUtc;
  /**
   * @return {?}
   */
  proto.zoneAbbr = function() {
    return this._isUTC ? "UTC" : "";
  };
  /**
   * @return {?}
   */
  proto.zoneName = function() {
    return this._isUTC ? "Coordinated Universal Time" : "";
  };
  proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
  proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
  proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
  proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function(val, keepLocalTime) {
    return null != val ? ("string" != typeof val && (val = -val), this.utcOffset(val, keepLocalTime), this) : -this.utcOffset();
  });
  proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function() {
    if (!isUndefined(this._isDSTShifted)) {
      return this._isDSTShifted;
    }
    var resultsSubject;
    var c = {};
    return copyConfig(c, this), (c = parse(c))._a ? (resultsSubject = (c._isUTC ? createUTC : createLocal)(c._a), this._isDSTShifted = this.isValid() && 0 < function(array1, array2, n) {
      /** @type {number} */
      var ncells = Math.min(array1.length, array2.length);
      /** @type {number} */
      var siteName = Math.abs(array1.length - array2.length);
      /** @type {number} */
      var managementcommandsdns = 0;
      /** @type {number} */
      var i = 0;
      for (; i < ncells; i++) {
        if (n && array1[i] !== array2[i] || !n && toInt(array1[i]) !== toInt(array2[i])) {
          managementcommandsdns++;
        }
      }
      return managementcommandsdns + siteName;
    }(c._a, resultsSubject.toArray())) : this._isDSTShifted = false, this._isDSTShifted;
  });
  var proto$1 = Locale.prototype;
  /**
   * @param {?} key
   * @param {?} mom
   * @param {?} now
   * @return {?}
   */
  proto$1.calendar = function(key, mom, now) {
    var output = this._calendar[key] || this._calendar.sameElse;
    return isFunction(output) ? output.call(mom, now) : output;
  };
  /**
   * @param {string} key
   * @return {?}
   */
  proto$1.longDateFormat = function(key) {
    var output = this._longDateFormat[key];
    var format = this._longDateFormat[key.toUpperCase()];
    return output || !format ? output : (this._longDateFormat[key] = format.match(separator).map(function(s) {
      return "MMMM" === s || "MM" === s || "DD" === s || "dddd" === s ? s.slice(1) : s;
    }).join(""), this._longDateFormat[key]);
  };
  /**
   * @return {?}
   */
  proto$1.invalidDate = function() {
    return this._invalidDate;
  };
  /**
   * @param {?} number
   * @return {?}
   */
  proto$1.ordinal = function(number) {
    return this._ordinal.replace("%d", number);
  };
  /** @type {function(!Object): ?} */
  proto$1.preparse = preParsePostFormat;
  /** @type {function(!Object): ?} */
  proto$1.postformat = preParsePostFormat;
  /**
   * @param {?} number
   * @param {boolean} withoutSuffix
   * @param {?} string
   * @param {?} isFuture
   * @return {?}
   */
  proto$1.relativeTime = function(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
  };
  /**
   * @param {number} diff
   * @param {!Object} output
   * @return {?}
   */
  proto$1.pastFuture = function(diff, output) {
    var format = this._relativeTime[0 < diff ? "future" : "past"];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
  };
  /**
   * @param {!Object} config
   * @return {undefined}
   */
  proto$1.set = function(config) {
    var fn;
    var prop;
    for (prop in config) {
      if (hasOwnProp(config, prop)) {
        if (isFunction(fn = config[prop])) {
          this[prop] = fn;
        } else {
          this["_" + prop] = fn;
        }
      }
    }
    /** @type {!Object} */
    this._config = config;
    /** @type {!RegExp} */
    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
  };
  /**
   * @param {?} formatters
   * @param {?} customFormatters
   * @return {?}
   */
  proto$1.eras = function(formatters, customFormatters) {
    var mDate;
    var results = this._eras || getLocale("en")._eras;
    /** @type {number} */
    var i = 0;
    var l = results.length;
    for (; i < l; ++i) {
      switch(typeof results[i].since) {
        case "string":
          mDate = hooks(results[i].since).startOf("day");
          results[i].since = mDate.valueOf();
          break;
      }
      switch(typeof results[i].until) {
        case "undefined":
          /** @type {number} */
          results[i].until = 1 / 0;
          break;
        case "string":
          mDate = hooks(results[i].until).startOf("day").valueOf();
          results[i].until = mDate.valueOf();
          break;
      }
    }
    return results;
  };
  /**
   * @param {string} y
   * @param {?} type
   * @param {?} default_alpha
   * @return {?}
   */
  proto$1.erasParse = function(y, type, default_alpha) {
    var i;
    var xl;
    var maskset;
    var opts;
    var swipingDirection;
    var enums = this.eras();
    y = y.toUpperCase();
    /** @type {number} */
    i = 0;
    xl = enums.length;
    for (; i < xl; ++i) {
      if (maskset = enums[i].name.toUpperCase(), opts = enums[i].abbr.toUpperCase(), swipingDirection = enums[i].narrow.toUpperCase(), default_alpha) {
        switch(type) {
          case "N":
          case "NN":
          case "NNN":
            if (opts === y) {
              return enums[i];
            }
            break;
          case "NNNN":
            if (maskset === y) {
              return enums[i];
            }
            break;
          case "NNNNN":
            if (swipingDirection === y) {
              return enums[i];
            }
            break;
        }
      } else {
        if (0 <= [maskset, opts, swipingDirection].indexOf(y)) {
          return enums[i];
        }
      }
    }
  };
  /**
   * @param {!Object} options
   * @param {!Array} val
   * @return {?}
   */
  proto$1.erasConvertYear = function(options, val) {
    /** @type {number} */
    var length = options.since <= options.until ? 1 : -1;
    return void 0 === val ? hooks(options.since).year() : hooks(options.since).year() + (val - options.offset) * length;
  };
  /**
   * @param {?} exception
   * @return {?}
   */
  proto$1.erasAbbrRegex = function(exception) {
    return hasOwnProp(this, "_erasAbbrRegex") || oldFinder.call(this), exception ? this._erasAbbrRegex : this._erasRegex;
  };
  /**
   * @param {?} a22
   * @return {?}
   */
  proto$1.erasNameRegex = function(a22) {
    return hasOwnProp(this, "_erasNameRegex") || oldFinder.call(this), a22 ? this._erasNameRegex : this._erasRegex;
  };
  /**
   * @param {?} a22
   * @return {?}
   */
  proto$1.erasNarrowRegex = function(a22) {
    return hasOwnProp(this, "_erasNarrowRegex") || oldFinder.call(this), a22 ? this._erasNarrowRegex : this._erasRegex;
  };
  /**
   * @param {!Object} m
   * @param {string} format
   * @return {?}
   */
  proto$1.months = function(m, format) {
    return m ? isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()] : isArray(this._months) ? this._months : this._months.standalone;
  };
  /**
   * @param {!Object} m
   * @param {string} format
   * @return {?}
   */
  proto$1.monthsShort = function(m, format) {
    return m ? isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()] : isArray(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
  };
  /**
   * @param {number} monthName
   * @param {string} format
   * @param {(Object|string)} strict
   * @return {?}
   */
  proto$1.monthsParse = function(monthName, format, strict) {
    var i;
    var mom;
    var relativeToPath;
    if (this._monthsParseExact) {
      return function(b, boardManager, n) {
        var i;
        var ii;
        var mom;
        var llc = b.toLocaleLowerCase();
        if (!this._monthsParse) {
          /** @type {!Array} */
          this._monthsParse = [];
          /** @type {!Array} */
          this._longMonthsParse = [];
          /** @type {!Array} */
          this._shortMonthsParse = [];
          /** @type {number} */
          i = 0;
          for (; i < 12; ++i) {
            mom = createUTC([2E3, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        return n ? "MMM" === boardManager ? -1 !== (ii = indexOf$1.call(this._shortMonthsParse, llc)) ? ii : null : -1 !== (ii = indexOf$1.call(this._longMonthsParse, llc)) ? ii : null : "MMM" === boardManager ? -1 !== (ii = indexOf$1.call(this._shortMonthsParse, llc)) || -1 !== (ii = indexOf$1.call(this._longMonthsParse, llc)) ? ii : null : -1 !== (ii = indexOf$1.call(this._longMonthsParse, llc)) || -1 !== (ii = indexOf$1.call(this._shortMonthsParse, llc)) ? ii : null;
      }.call(this, monthName, format, strict);
    }
    if (!this._monthsParse) {
      /** @type {!Array} */
      this._monthsParse = [];
      /** @type {!Array} */
      this._longMonthsParse = [];
      /** @type {!Array} */
      this._shortMonthsParse = [];
    }
    /** @type {number} */
    i = 0;
    for (; i < 12; i++) {
      if (mom = createUTC([2E3, i]), strict && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i"), this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i")), strict || this._monthsParse[i] || (relativeToPath = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, ""), this._monthsParse[i] = new RegExp(relativeToPath.replace(".", ""), "i")), strict && "MMMM" === format && this._longMonthsParse[i].test(monthName)) {
        return i;
      }
      if (strict && "MMM" === format && this._shortMonthsParse[i].test(monthName)) {
        return i;
      }
      if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  };
  /**
   * @param {string} isStrict
   * @return {?}
   */
  proto$1.monthsRegex = function(isStrict) {
    return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), isStrict ? this._monthsStrictRegex : this._monthsRegex) : (hasOwnProp(this, "_monthsRegex") || (this._monthsRegex = defaultMonthsRegex), this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex);
  };
  /**
   * @param {number} isStrict
   * @return {?}
   */
  proto$1.monthsShortRegex = function(isStrict) {
    return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex) : (hasOwnProp(this, "_monthsShortRegex") || (this._monthsShortRegex = defaultMonthsShortRegex), this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex);
  };
  /**
   * @param {!Object} mom
   * @return {?}
   */
  proto$1.week = function(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  };
  /**
   * @return {?}
   */
  proto$1.firstDayOfYear = function() {
    return this._week.doy;
  };
  /**
   * @return {?}
   */
  proto$1.firstDayOfWeek = function() {
    return this._week.dow;
  };
  /**
   * @param {!Object} m
   * @param {string} format
   * @return {?}
   */
  proto$1.weekdays = function(m, format) {
    var x = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && true !== m && this._weekdays.isFormat.test(format) ? "format" : "standalone"];
    return true === m ? data_extract(x, this._week.dow) : m ? x[m.day()] : x;
  };
  /**
   * @param {!Object} m
   * @return {?}
   */
  proto$1.weekdaysMin = function(m) {
    return true === m ? data_extract(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
  };
  /**
   * @param {!Object} m
   * @return {?}
   */
  proto$1.weekdaysShort = function(m) {
    return true === m ? data_extract(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
  };
  /**
   * @param {!Object} name
   * @param {string} data
   * @param {(!Function|string)} options
   * @return {?}
   */
  proto$1.weekdaysParse = function(name, data, options) {
    var i;
    var mom;
    var relativeToPath;
    if (this._weekdaysParseExact) {
      return function(b, canCreateDiscussions, n) {
        var i;
        var ii;
        var mom;
        var llc = b.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          /** @type {!Array} */
          this._weekdaysParse = [];
          /** @type {!Array} */
          this._shortWeekdaysParse = [];
          /** @type {!Array} */
          this._minWeekdaysParse = [];
          /** @type {number} */
          i = 0;
          for (; i < 7; ++i) {
            mom = createUTC([2E3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        return n ? "dddd" === canCreateDiscussions ? -1 !== (ii = indexOf$1.call(this._weekdaysParse, llc)) ? ii : null : "ddd" === canCreateDiscussions ? -1 !== (ii = indexOf$1.call(this._shortWeekdaysParse, llc)) ? ii : null : -1 !== (ii = indexOf$1.call(this._minWeekdaysParse, llc)) ? ii : null : "dddd" === canCreateDiscussions ? -1 !== (ii = indexOf$1.call(this._weekdaysParse, llc)) || -1 !== (ii = indexOf$1.call(this._shortWeekdaysParse, llc)) || -1 !== (ii = indexOf$1.call(this._minWeekdaysParse, 
        llc)) ? ii : null : "ddd" === canCreateDiscussions ? -1 !== (ii = indexOf$1.call(this._shortWeekdaysParse, llc)) || -1 !== (ii = indexOf$1.call(this._weekdaysParse, llc)) || -1 !== (ii = indexOf$1.call(this._minWeekdaysParse, llc)) ? ii : null : -1 !== (ii = indexOf$1.call(this._minWeekdaysParse, llc)) || -1 !== (ii = indexOf$1.call(this._weekdaysParse, llc)) || -1 !== (ii = indexOf$1.call(this._shortWeekdaysParse, llc)) ? ii : null;
      }.call(this, name, data, options);
    }
    if (!this._weekdaysParse) {
      /** @type {!Array} */
      this._weekdaysParse = [];
      /** @type {!Array} */
      this._minWeekdaysParse = [];
      /** @type {!Array} */
      this._shortWeekdaysParse = [];
      /** @type {!Array} */
      this._fullWeekdaysParse = [];
    }
    /** @type {number} */
    i = 0;
    for (; i < 7; i++) {
      if (mom = createUTC([2E3, 1]).day(i), options && !this._fullWeekdaysParse[i] && (this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[i] || (relativeToPath = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, 
      "") + "|^" + this.weekdaysMin(mom, ""), this._weekdaysParse[i] = new RegExp(relativeToPath.replace(".", ""), "i")), options && "dddd" === data && this._fullWeekdaysParse[i].test(name)) {
        return i;
      }
      if (options && "ddd" === data && this._shortWeekdaysParse[i].test(name)) {
        return i;
      }
      if (options && "dd" === data && this._minWeekdaysParse[i].test(name)) {
        return i;
      }
      if (!options && this._weekdaysParse[i].test(name)) {
        return i;
      }
    }
  };
  /**
   * @param {string} isStrict
   * @return {?}
   */
  proto$1.weekdaysRegex = function(isStrict) {
    return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex) : (hasOwnProp(this, "_weekdaysRegex") || (this._weekdaysRegex = defaultWeekdaysRegex), this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex);
  };
  /**
   * @param {string} isStrict
   * @return {?}
   */
  proto$1.weekdaysShortRegex = function(isStrict) {
    return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (hasOwnProp(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = defaultWeekdaysShortRegex), this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
  };
  /**
   * @param {string} isStrict
   * @return {?}
   */
  proto$1.weekdaysMinRegex = function(isStrict) {
    return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (hasOwnProp(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = defaultWeekdaysMinRegex), this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
  };
  /**
   * @param {string} input
   * @return {?}
   */
  proto$1.isPM = function(input) {
    return "p" === (input + "").toLowerCase().charAt(0);
  };
  /**
   * @param {number} minutes
   * @param {?} hours
   * @param {string} isLower
   * @return {?}
   */
  proto$1.meridiem = function(minutes, hours, isLower) {
    return 11 < minutes ? isLower ? "pm" : "PM" : isLower ? "am" : "AM";
  };
  getSetGlobalLocale("en", {
    eras : [{
      since : "0001-01-01",
      until : 1 / 0,
      offset : 1,
      name : "Anno Domini",
      narrow : "AD",
      abbr : "AD"
    }, {
      since : "0000-12-31",
      until : -1 / 0,
      offset : 1,
      name : "Before Christ",
      narrow : "BC",
      abbr : "BC"
    }],
    dayOfMonthOrdinalParse : /\d{1,2}(th|st|nd|rd)/,
    ordinal : function(number) {
      /** @type {number} */
      var rem100 = number % 10;
      return number + (1 === toInt(number % 100 / 10) ? "th" : 1 == rem100 ? "st" : 2 == rem100 ? "nd" : 3 == rem100 ? "rd" : "th");
    }
  });
  hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
  hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
  /** @type {function(?): number} */
  var mathAbs = Math.abs;
  var asMilliseconds = makeAs("ms");
  var asSeconds = makeAs("s");
  var asMinutes = makeAs("m");
  var asHours = makeAs("h");
  var asDays = makeAs("d");
  var asWeeks = makeAs("w");
  var asMonths = makeAs("M");
  var that = makeAs("Q");
  var asYears = makeAs("y");
  var milliseconds = makeGetter("milliseconds");
  var seconds = makeGetter("seconds");
  var minutes = makeGetter("minutes");
  var hours = makeGetter("hours");
  var days = makeGetter("days");
  var months = makeGetter("months");
  var years = makeGetter("years");
  /** @type {function(?): number} */
  var round = Math.round;
  var thresholds = {
    ss : 44,
    s : 45,
    m : 45,
    h : 22,
    d : 26,
    w : null,
    M : 11
  };
  /** @type {function(?): number} */
  var iso_string__abs = Math.abs;
  var proto$2 = Duration.prototype;
  return proto$2.isValid = function() {
    return this._isValid;
  }, proto$2.abs = function() {
    var data = this._data;
    return this._milliseconds = mathAbs(this._milliseconds), this._days = mathAbs(this._days), this._months = mathAbs(this._months), data.milliseconds = mathAbs(data.milliseconds), data.seconds = mathAbs(data.seconds), data.minutes = mathAbs(data.minutes), data.hours = mathAbs(data.hours), data.months = mathAbs(data.months), data.years = mathAbs(data.years), this;
  }, proto$2.add = function(input, value) {
    return addSubtract$1(this, input, value, 1);
  }, proto$2.subtract = function(input, value) {
    return addSubtract$1(this, input, value, -1);
  }, proto$2.as = function(units) {
    if (!this.isValid()) {
      return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;
    if ("month" === (units = normalizeUnits(units)) || "quarter" === units || "year" === units) {
      switch(days = this._days + milliseconds / 864E5, months = this._months + daysToYears(days), units) {
        case "month":
          return months;
        case "quarter":
          return months / 3;
        case "year":
          return months / 12;
      }
    } else {
      switch(days = this._days + Math.round(monthsToDays(this._months)), units) {
        case "week":
          return days / 7 + milliseconds / 6048E5;
        case "day":
          return days + milliseconds / 864E5;
        case "hour":
          return 24 * days + milliseconds / 36E5;
        case "minute":
          return 1440 * days + milliseconds / 6E4;
        case "second":
          return 86400 * days + milliseconds / 1E3;
        case "millisecond":
          return Math.floor(864E5 * days) + milliseconds;
        default:
          throw new Error("Unknown unit " + units);
      }
    }
  }, proto$2.asMilliseconds = asMilliseconds, proto$2.asSeconds = asSeconds, proto$2.asMinutes = asMinutes, proto$2.asHours = asHours, proto$2.asDays = asDays, proto$2.asWeeks = asWeeks, proto$2.asMonths = asMonths, proto$2.asQuarters = that, proto$2.asYears = asYears, proto$2.valueOf = function() {
    return this.isValid() ? this._milliseconds + 864E5 * this._days + this._months % 12 * 2592E6 + 31536E6 * toInt(this._months / 12) : NaN;
  }, proto$2._bubble = function() {
    var seconds;
    var minutes;
    var hours;
    var years;
    var monthsFromDays;
    var milliseconds = this._milliseconds;
    var days = this._days;
    var months = this._months;
    var data = this._data;
    return 0 <= milliseconds && 0 <= days && 0 <= months || milliseconds <= 0 && days <= 0 && months <= 0 || (milliseconds = milliseconds + 864E5 * absCeil(monthsToDays(months) + days), months = days = 0), data.milliseconds = milliseconds % 1E3, seconds = absFloor(milliseconds / 1E3), data.seconds = seconds % 60, minutes = absFloor(seconds / 60), data.minutes = minutes % 60, hours = absFloor(minutes / 60), data.hours = hours % 24, days = days + absFloor(hours / 24), months = months + (monthsFromDays = 
    absFloor(daysToYears(days))), days = days - absCeil(monthsToDays(monthsFromDays)), years = absFloor(months / 12), months = months % 12, data.days = days, data.months = months, data.years = years, this;
  }, proto$2.clone = function() {
    return createDuration(this);
  }, proto$2.get = function(units) {
    return units = normalizeUnits(units), this.isValid() ? this[units + "s"]() : NaN;
  }, proto$2.milliseconds = milliseconds, proto$2.seconds = seconds, proto$2.minutes = minutes, proto$2.hours = hours, proto$2.days = days, proto$2.weeks = function() {
    return absFloor(this.days() / 7);
  }, proto$2.months = months, proto$2.years = years, proto$2.humanize = function(n, t) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    var locale;
    var output;
    /** @type {boolean} */
    var withSuffix = false;
    var d = thresholds;
    return "object" == typeof n && (t = n, n = false), "boolean" == typeof n && (withSuffix = n), "object" == typeof t && (d = Object.assign({}, thresholds, t), null != t.s && null == t.ss && (d.ss = t.s - 1)), locale = this.localeData(), output = relativeTime(this, !withSuffix, d, locale), withSuffix && (output = locale.pastFuture(+this, output)), locale.postformat(output);
  }, proto$2.toISOString = toISOString$1, proto$2.toString = toISOString$1, proto$2.toJSON = toISOString$1, proto$2.locale = locale, proto$2.localeData = localeData, proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1), proto$2.lang = lang, addFormatToken("X", 0, 0, "unix"), addFormatToken("x", 0, 0, "valueOf"), addRegexToken("x", match3to4), addRegexToken("X", /[+-]?\d+(\.\d{1,3})?/), addParseToken("X", function(IDM_s0, 
  canCreateDiscussions, day) {
    /** @type {!Date} */
    day._d = new Date(1E3 * parseFloat(IDM_s0));
  }), addParseToken("x", function(value, canCreateDiscussions, day) {
    /** @type {!Date} */
    day._d = new Date(toInt(value));
  }), hooks.version = "2.29.1", oldSetupComputes = createLocal, hooks.fn = proto, hooks.min = function() {
    return pickBy("isBefore", [].slice.call(arguments, 0));
  }, hooks.max = function() {
    return pickBy("isAfter", [].slice.call(arguments, 0));
  }, hooks.now = function() {
    return Date.now ? Date.now() : +new Date;
  }, hooks.utc = createUTC, hooks.unix = function(moment) {
    return createLocal(1E3 * moment);
  }, hooks.months = function(format, value) {
    return listMonthsImpl(format, value, "months");
  }, hooks.isDate = isDate, hooks.locale = getSetGlobalLocale, hooks.invalid = createInvalid, hooks.duration = createDuration, hooks.isMoment = isMoment, hooks.weekdays = function(m, format, index) {
    return listWeekdaysImpl(m, format, index, "weekdays");
  }, hooks.parseZone = function() {
    return createLocal.apply(null, arguments).parseZone();
  }, hooks.localeData = getLocale, hooks.isDuration = isDuration, hooks.monthsShort = function(format, index) {
    return listMonthsImpl(format, index, "monthsShort");
  }, hooks.weekdaysMin = function(m, format, index) {
    return listWeekdaysImpl(m, format, index, "weekdaysMin");
  }, hooks.defineLocale = defineLocale, hooks.updateLocale = function(name, config) {
    var locale;
    var mod;
    var parentConfig;
    return null != config ? (parentConfig = baseConfig, null != locales[name] && null != locales[name].parentLocale ? locales[name].set(mergeConfigs(locales[name]._config, config)) : (null != (mod = require(name)) && (parentConfig = mod._config), config = mergeConfigs(parentConfig, config), null == mod && (config.abbr = name), (locale = new Locale(config)).parentLocale = locales[name], locales[name] = locale), getSetGlobalLocale(name)) : null != locales[name] && (null != locales[name].parentLocale ? 
    (locales[name] = locales[name].parentLocale, name === getSetGlobalLocale() && getSetGlobalLocale(name)) : null != locales[name] && delete locales[name]), locales[name];
  }, hooks.locales = function() {
    return callback(locales);
  }, hooks.weekdaysShort = function(m, format, lang) {
    return listWeekdaysImpl(m, format, lang, "weekdaysShort");
  }, hooks.normalizeUnits = normalizeUnits, hooks.relativeTimeRounding = function(cond) {
    return void 0 === cond ? round : "function" == typeof cond && (round = cond, true);
  }, hooks.relativeTimeThreshold = function(threshold, limit) {
    return void 0 !== thresholds[threshold] && (void 0 === limit ? thresholds[threshold] : (thresholds[threshold] = limit, "s" === threshold && (thresholds.ss = limit - 1), true));
  }, hooks.calendarFormat = function(myMoment, now) {
    var diff = myMoment.diff(now, "days", true);
    return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
  }, hooks.prototype = proto, hooks.HTML5_FMT = {
    DATETIME_LOCAL : "YYYY-MM-DDTHH:mm",
    DATETIME_LOCAL_SECONDS : "YYYY-MM-DDTHH:mm:ss",
    DATETIME_LOCAL_MS : "YYYY-MM-DDTHH:mm:ss.SSS",
    DATE : "YYYY-MM-DD",
    TIME : "HH:mm",
    TIME_SECONDS : "HH:mm:ss",
    TIME_MS : "HH:mm:ss.SSS",
    WEEK : "GGGG-[W]WW",
    MONTH : "YYYY-MM"
  }, hooks;
});



// moment.js language configuration
// language : spanish (es)
// author : Julio Napurí : https://github.com/julionc

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['moment'], factory); // AMD
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../moment')); // Node
    } else {
        factory(window.moment); // Browser global
    }
}(function (moment) {
    return moment.lang('es', {
        months : "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
        monthsShort : "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
        weekdays : "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
        weekdaysShort : "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
        weekdaysMin : "Do_Lu_Ma_Mi_Ju_Vi_Sá".split("_"),
        longDateFormat : {
            LT : "H:mm",
            L : "DD/MM/YYYY",
            LL : "D [de] MMMM [de] YYYY",
            LLL : "D [de] MMMM [de] YYYY LT",
            LLLL : "dddd, D [de] MMMM [de] YYYY LT"
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : "en %s",
            past : "hace %s",
            s : "unos segundos",
            m : "un minuto",
            mm : "%d minutos",
            h : "una hora",
            hh : "%d horas",
            d : "un día",
            dd : "%d días",
            M : "un mes",
            MM : "%d meses",
            y : "un año",
            yy : "%d años"
        },
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });
}));
